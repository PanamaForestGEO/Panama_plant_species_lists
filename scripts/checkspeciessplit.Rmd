---
title: "checkandmergesplits"
author: "Helene Muller-Landau, Paula Uzcategui"
date: "2026-02-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Check and merge splits Markdown

Put this document in the main folder to run it

This document is intended to help correct errors in a woody species list, including correcting and filling missing information for:
species code (sp6, sp4), species name, author, order, genus, family, subspecies, voucher. And also to leave a register of synonyms or names changes.

Make sure to save the html output of running document with the name and date of the raw species lists in the reports folder.

Some errors can be addressed automatically, others need manual checks.

Prior versions checked species names against TNRS.  The current version checks against WCVP. (World Checklist of Vascular Plants).


```{r setpath, include=FALSE}
rm(list=ls())
```

```{r libraries, echo=TRUE, results="hide", message=FALSE, warning=FALSE,}
library("readxl")
library("writexl")
library("dplyr")
library(tidyr)
library("stringi")
library("stringr")
suppressPackageStartupMessages({
  library(rWCVP)
  library(rWCVPdata)
})
library(knitr)
library(DT)

```

```{r initialsetup, echo=TRUE, results="hide"}
rm(list=ls())

redoWCVP = FALSE

FIX_SPECIES = TRUE # a new file will be saved with the fixed species names. 

DIRINSP <- "splists_raw/"
DIRMIDSP <- "splists_mid/"
DIROUTSP <- "splists_out/"
DIRCHECK <- "tocheck/"

# input files # all in directory DIRINSP
FNWRIGHTSPLISTIN <- "splists_out/Wright_20210224_WCVP_2026-02-19.xlsx"
FNFGEOSPLISTIN <- "Forestgeo/2025-12-04FromSuzanne/ViewTaxonomy_dec4_25.xlsx"
FNPANAMASPLISTIN <- "PanamaWoodySpLists/2025-12-04FromSuzanne/FloradePanama_dec4_2025_HM.xlsx" 


FNPANAMASPLISTWCVP <- paste0(DIRMIDSP,tools::file_path_sans_ext(basename(FNPANAMASPLISTIN)),"_WCVP_MATCH.xlsx")

PANAMA_COMBINED_OUT_PATH <- paste0(DIROUTSP,"CurrentPanamaWoody_",Sys.Date(),".xlsx")

PANAMA_COMBINED_CHANGE_SUMMARY_PATH <- paste0(DIROUTSP,"CurrentPanamaWoody_CHANGES_",Sys.Date(),".xlsx")

WRIGHT_MISSING_PANWOODY_PATH = paste0(DIROUTSP,"Wright_not_CurrentPanamaWoody_",Sys.Date(),".xlsx")
  
FNPANAMATAXA <- paste0(DIROUTSP,"AllTaxa_CurrentPanamaWoody_",Sys.Date(),".xlsx")

FNSYNONYMS <- paste0(DIROUTSP,"CurrentPanamaWoody_SYNONYMS_",Sys.Date(),".xlsx")

# the last is the list of all unique accepted species, genera, and families for photo labeling

```

We will: 

1. Make sure sp6 codes in the woody list are consistent with forestgeo codes

2. Match woody species names to wcvp

3. Match sp4 codes from wright list


## Load the ForestGEO viewtaxonomy dataset

We use this dataset to match species names with species sp6 codes

```{r loadspfgeotaxa, echo=TRUE}
# ForestGEO dataset of taxonomy for species codes used in Panama plot censuses - includes morphospecies

treeplottaxa <- read_excel(paste0(DIRINSP,FNFGEOSPLISTIN))

treeplottaxa <- treeplottaxa %>%
mutate(across(everything(), ~ {
  if(is.character(.)) {
    na_if(., "NULL") # Solo aplica na_if si la columna es texto
  } else {
    . # Si es numérica, la deja igual
  }
}))

 #set the code to the subspecies code if it is a subspecies
treeplottaxa <- treeplottaxa %>% 
  mutate(
         sp6 = ifelse(is.na(Subspecies), Mnemonic, subspMnemonic), 
         binomial=ifelse(Genus=="Unidentified",paste(Genus,sp6),paste(Genus,SpeciesName)),
         species_name=ifelse(is.na(Subspecies),
                                paste0(Genus," ",SpeciesName),
                                paste0(Genus," ",SpeciesName," ",Rank, " ", Subspecies))
       )
  

treeplottaxa$binomial <- stri_trans_general(treeplottaxa$binomial,"Latin-ASCII")

sp6dups <- treeplottaxa %>% group_by(sp6) %>% filter(n()>1) %>% ungroup()
  
if(nrow(sp6dups) > 0){
  knitr::kable(sp6dups %>% select(sp6, species_name), caption="Duplicated sp6 codes in forestgeo viewtaxa")
} else{
  print("No duplicated codes")
}
  

# handle duplicates if there are any
spnamedups <- treeplottaxa %>% group_by(species_name) %>% filter(n()>1) %>% ungroup() %>% arrange(species_name)
  
if(nrow(spnamedups) > 0){
    datatable(spnamedups %>% select(sp6, species_name, IDLevel), caption="Duplicated species names in forestgeo viewtaxa",options = list(scrollX = TRUE, pageLength = 10))
} else{
    print("No duplicated species names")
}
  
# leave because they have codes 

fgeotaxa <- treeplottaxa
```

## Load Wright species list dataset: 

We will use the sp6 codes and species names to find matches for sp4 codes. 

```{r loadspwright, echo=TRUE}
# Joe Wright's taxonomy dataset (includes 4-letter codes and some non-woody species as well as trees and lianas)

# this list was already processed with the wcvp v13 names
usewrighttaxa <- read_excel(FNWRIGHTSPLISTIN)

```
 
## Load woody species list to be processed

```{r loadsppanama, echo=TRUE}

# ForestGEO Panama woody plant species list 
panwoodtaxa <- read_excel(paste0(DIRINSP,FNPANAMASPLISTIN),col_types="text")  %>%
  rename(Current_order=taxorder,
         Current_family=family,
         Current_genus=genus,
         Current_species=speciesname,
         Current_name_author=authority,
         Current_subspecies=subspecies,
         synonyms=synonyms,
         sp6curr=mnemonic,
         vouchers=herbarium,
         habit=liana) %>%
  mutate(sp6curr=tolower(sp6curr),
         habit=ifelse(habit=="l","Climbing","Freestanding"),
         Current_name=ifelse(is.na(Current_subspecies),
                                paste0(Current_genus," ",Current_species),
                                paste0(Current_genus," ",Current_species," ",Current_subspecies)),
         Current_name = str_trim(Current_name),
         habit=ifelse(is.na(habit),"Freestanding",habit),
         sp6prior=fgeotaxa$sp6[match(Current_name,fgeotaxa$species_name)])
  
```

Number of species in Panama woody plant species list: `r paste(nrow(panwoodtaxa))`

# Check for consistency of sp6 codes

We initially match sp6 prior using the raw species names

```{r checkmalformed, echo=TRUE}
# after matching sp6 prior by species name:

panwoodtaxa <- panwoodtaxa %>% mutate(
  sp6 = coalesce(sp6curr, sp6prior),
  binomial = paste0(Current_genus, " ", Current_species))

#  check for duplicated codes
sp6dups <- panwoodtaxa %>% filter(!is.na(sp6)) %>% group_by(sp6) %>% 
  arrange(sp6) %>% filter(n()>1) %>% ungroup()
 
sp6problems <- panwoodtaxa %>%
  filter(
    is.na(sp6) | 
      (!is.na(sp6) & !is.na(sp6prior) & sp6 != sp6prior) | 
      (!is.na(sp6) & nchar(sp6) != 6) | 
      (sp6 %in% sp6dups)
  ) %>%
  mutate(problem_reason = case_when(
    is.na(sp6)                ~ "Code is missing (NULL)",
    sp6 != sp6prior           ~ "Code mismatch with prior record",
    nchar(sp6) != 6           ~ "Code is not 6 characters",
    sp6 %in% sp6dups          ~ "Duplicate species code",
    TRUE                      ~ "Unknown error"
  ))

if(nrow(sp6problems) > 0){
  knitr::kable(sp6problems %>% select(sp6, sp6curr, sp6prior, Current_name), caption="Species code problems")
} else { print("No inconsistency with the codes")}


# check for 6-letter codes in the Fgeo codes list that are not in the Panama woody plant species list (and are for identified species)
sp6dropped <- subset(fgeotaxa,!sp6 %in% panwoodtaxa$sp6 
                       &IDLevel=="species") %>%
      mutate(binomial_in_flora=binomial %in% panwoodtaxa$binomial) %>%
      arrange(sp6)

if(nrow(sp6dropped) > 0){
  datatable(
    sp6dropped %>% select(sp6, species_name, binomial_in_flora),
    caption="Species in forestgeo list not in tha panama woody list. binomial_in_flora = TRUE means the binomial name does show in   forestgeo list",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )

} else{ print("All identified species in forestgeo are in the panama woody list")}

# check fo na prior
sp6match_namenomatch <- panwoodtaxa %>% filter(is.na(sp6prior)) %>% left_join(fgeotaxa %>% select(sp6, species_name, Subspecies), by=c("sp6curr" = "sp6")) %>% filter(!is.na(species_name)) %>% 
  select(sp6curr, sp6prior, Current_name, species_name, Subspecies) %>%
  rename(sp6= sp6curr, species_name_panwood = Current_name, species_name_fgeotaxa = species_name, subspecies_fgeotaxa = Subspecies  )
  
if(nrow(sp6match_namenomatch) > 0){
  knitr::kable(sp6match_namenomatch, caption="Species code in fgeotaxa matches with panama wood but the species name dont match")
} else { print("No inconsistency with the same code pointing to different names in fgeo and panama woody")}



# check for 6-letter codes in panama woody that are not in forestgeo 
sp6dropped_woody <- subset(panwoodtaxa,!sp6 %in% fgeotaxa$sp6) %>%
      mutate(binomial_in_flora=binomial %in% fgeotaxa$binomial) %>%
      arrange(sp6)

if(nrow(sp6dropped_woody) > 0){
  datatable(
    sp6dropped_woody %>% select(sp6, sp6curr, sp6prior, Current_name, binomial_in_flora),
    caption="Species in panama woody that are not in the forestgeo list. binomial_in_flora = TRUE means the binomial name does show in   forestgeo list",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
} else{ print("All identified species in panama woody appear in the forestgeo list")}


```

## Check duplicated names
```{r checkduplicate, echo=TRUE, results="hide"}
# check for duplicate binomials and address if needed
bindups <- panwoodtaxa %>% group_by(Current_name) %>% arrange(Current_name) %>% filter(n()>1) %>% ungroup()

nrow(bindups)
```

- Duplicated species names: `r paste(nrow(bindups))`

```{r showbindups}
if (nrow(bindups) > 0) { 
    knitr::kable(bindups %>% select(Current_name, sp6curr), captio="Duplicated species names")
    write_xlsx(bindups,paste0(DIRCHECK,tools::file_path_sans_ext(basename(FNPANAMASPLISTIN)),"_nombreduplicado.xlsx"))
}
``` 

⚠️ If there are duplicates, manually check and leave the correct species in the "_touse" file:
```{r manuadupcheck}
if (nrow(bindups)>0 & file.exists(paste0(DIRCHECK,tools::file_path_sans_ext(basename(FNPANAMASPLISTIN)),"_touse.xlsx"))) 
  {
  # currently no duplicates!
  # previously, I manually went through and picked one of the entries as correct for each duplicated Current_name
  # exception is Swartzia simplex, where both are good
  panwoodtaxa <- filter(panwoodtaxa, !Current_name %in% bindups$Current_name)
  gooddups <- read_excel(paste0(DIRCHECK,tools::file_path_sans_ext(basename(FNPANAMASPLISTIN)),"_touse.xlsx"))
  panwoodtaxa <- rbind(panwoodtaxa,gooddups)
} else{
  print("Found no file to repair duplicates")
}
```

Change the Current_name to forestgeo_name
Many names in the original file will change after using WCVP but mainly because of spelling differences.
```{r changenames, echo=TRUE, results="hide"}

panwoodtaxa <- panwoodtaxa %>% 
  rename(
    forestgeo_name = Current_name,
    forestgeo_genus = Current_genus,
    forestgeo_species = Current_species,
    forestgeo_family = Current_family,
    forestgeo_order = Current_order,
    forestgeo_author = Current_name_author,
    forestgeo_subspecies = Current_subspecies,
    forestgeo_synonyms = synonyms
  )

```


# Match species names with WCVP v13:

Species names might have changed. We will add a new column current_name with the species name after checking with WCVP v13.

The current_name column has by default the forestgeo name, but it changes to the WCVP name if:

1. If species spelling differs, we keep the wcvp spelling
2. If species name is a synonym or illegitimate we keep the wcvp name

Otherwise keep the forestgeo_name as current name if:

1. Name matched by wcvp is not good
2. If the name is not accepted but WCVP match means that 2 or more forestgeo species would have the same WCVP name.
3. If no match to WCVP but it has a code, then leave it.  
4. The wcvp name doesnt have the subspecies in the original name

At the end we have the same number of species. And we have columns:

current_name -> the name according to the criteria defined above
forestgeo_name -> the name as it appears in the forestgeo table
wcvp_name -> the accepted name according to wcvp
wcvp_name_matched -> the name matched by wcvp 


```{r trywcvp, echo=TRUE, results="hide"}

# load the wcvp names
# match with the species list
# check for duplicates and fix
# merge with the accepted names


########### MATCHING NAMES USING WCVP ###########################################################

wcvp_names <- rWCVPdata::wcvp_names 

# function to look for accepted name by the accepted name id returned from the wcvp library matching function
matchaccepted_names<- function(matcheswcvp){
  matcheswcvp %>% 
    left_join(wcvp_names %>% select(plant_name_id, genus, species, taxon_rank, family, primary_author, infraspecific_rank, infraspecies, lifeform_description, taxon_status),
              by=c("wcvp_accepted_id"="plant_name_id")) %>% 
    mutate(
      Accepted_name = case_when(
        is.na(species) | species == "" ~ genus,
        !is.na(infraspecies) & infraspecies != "" ~ paste(genus, species, infraspecific_rank, infraspecies),
        TRUE ~ paste(genus, species))
    ) %>%
    rename(
      Accepted_family= family,
      Accepted_name_rank = taxon_rank,
      Accepted_name_author = primary_author,
      Accepted_name_status = taxon_status,
      Accepted_name_genus = genus, 
      Accepted_name_species = species, 
      Accepted_name_infraspecific_rank = infraspecific_rank, 
      Accepted_name_infraspecies = infraspecies
    )
}


####################### Merge taxa with wcvp names 
# this can take a while, so save the file when finished
if(file.exists(FNPANAMASPLISTWCVP) & !redoWCVP){
  panwoodtaxawcvp <- read_excel(FNPANAMASPLISTWCVP)  
} else{
  panwoodtaxawcvp <-wcvp_match_names(panwoodtaxa, wcvp_names, name_col="forestgeo_name")
  write_xlsx(panwoodtaxawcvp, FNPANAMASPLISTWCVP)
}

# This should be TRUE
all(unique(panwoodtaxawcvp$forestgeo_name) %in% unique(panwoodtaxa$forestgeo_name))

# There can be multiple matches for one species, but only one is considered accepted
#sanity check of that
panwoodtaxawcvp %>%
  group_by(forestgeo_name) %>%
  summarise(
    n_rows = n(),
    n_accepted = sum(wcvp_status == "Accepted", na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(n_accepted > 1)


# If they have two accepted names its probably because they were registered twice. The two records have different ids
# rules to keep 1 name per species:
# if there is only one record with the current name keep that.
# if there are more than one keep the one with wcvp_status = "Accepted"
panwoodtaxawcvp_clean <- panwoodtaxawcvp %>%
  mutate(
    status_priority = case_when(
      wcvp_status == "Accepted"     ~ 1,
      wcvp_status == "Synonym"      ~ 2,
      wcvp_status == "Illegitimate" ~ 3,
      wcvp_status == "Unplaced"     ~ 4,
      TRUE                          ~ 5
    )
  ) %>%
  group_by(forestgeo_name) %>%
  slice_min(status_priority, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(-status_priority)

# Now this should be TRUE.
nrow(panwoodtaxawcvp_clean) == nrow(panwoodtaxa) 

# sanity check one species per row
panwoodtaxawcvp_clean %>%
  group_by(forestgeo_name) %>%
  summarise(
    n_rows = n(),
    .groups = "drop"
  ) %>%
  filter(n_rows > 1)

# Add the accepted names
panwoodtaxawcvp_clean <- matchaccepted_names(panwoodtaxawcvp_clean)

# Now left join to make sure the number of species is consistent.
panwoodtaxawcvpplus <-   panwoodtaxa %>%
  left_join(panwoodtaxawcvp_clean %>% 
              select(forestgeo_name, wcvp_name, wcvp_authors,wcvp_rank, wcvp_status, 
                     Accepted_name, Accepted_family, Accepted_name_rank, Accepted_name_author, Accepted_name_status,
                     Accepted_name_genus,
                     Accepted_name_species, 
                     Accepted_name_infraspecific_rank, 
                     Accepted_name_infraspecies,
                     lifeform_description, match_similarity, match_edit_distance),
            by="forestgeo_name") %>%
  rename(
    Name_matched = wcvp_name,
    Name_matched_rank = wcvp_rank
  )

# This should be TRUE
nrow(panwoodtaxawcvpplus)  == nrow(panwoodtaxa) 

# For mysterious reasons some species have accepted status but dont have accepted name ...
panwoodtaxawcvpplus %>% filter(is.na(Accepted_name)) %>% select(forestgeo_name, Name_matched, wcvp_status)

# in that case leave the Name-matched as the accepted_name 
inc <- panwoodtaxawcvpplus$Accepted_name=="" | is.na(panwoodtaxawcvpplus$Accepted_name)
if (any(inc, na.rm = TRUE)) {
  table(inc)
  panwoodtaxawcvpplus$Accepted_name[inc] <- panwoodtaxawcvpplus$Name_matched[inc]
  panwoodtaxawcvpplus$Accepted_name_rank[inc] <- panwoodtaxawcvpplus$Name_matched_rank[inc]
  panwoodtaxawcvpplus$Accepted_name_author[inc] <- ifelse(is.na(panwoodtaxawcvpplus$Accepted_name_author[inc]) & panwoodtaxawcvpplus$Accepted_name[inc] == panwoodtaxawcvpplus$forestgeo_name[inc],
                                                      panwoodtaxawcvpplus$forestgeo_author[inc],
                                                      panwoodtaxawcvpplus$Accepted_name_author[inc]
  )
}

# lets see the taxonomic status of the matches
panwoodtaxawcvpplus %>% 
  count(wcvp_status, name = "n")

```


This should TRUE if after running the matches with wcvp, each species keeps only one match with WCVP:
```{r wcvpsanity}
 paste0("One wcvp name match per species: ", nrow(panwoodtaxawcvp_clean) == nrow(panwoodtaxa))
```

Species matched and their taxonomic status:
```{r wcvpstatus}
 knitr::kable(panwoodtaxawcvpplus %>% 
  count(wcvp_status, name = "n"), caption="Species matched and their taxonomic status")
```


Next we will detect inconsistencies in the matched names and the accepted names and correct errors as we go. A record of the changes will be kept in a separate file. 

```{r setwcvpname, echo=TRUE, results="hide"}

# For now lets assume the original forestgeoname is correct 
panwoodtaxawcvpplus <- panwoodtaxawcvpplus %>% mutate(
  wcvp_name = Accepted_name,
  wcvp_family = Accepted_family,
  wcvp_genus = Accepted_name_genus,
  wcvp_species = Accepted_name_species,
  wcvp_author = Accepted_name_author,
  wcvp_subspecies = Accepted_name_infraspecies,
  wcvp_subspecies_rank = Accepted_name_infraspecific_rank,
  current_name = forestgeo_name,
  current_family = forestgeo_family,
  current_genus = forestgeo_genus,
  current_species = forestgeo_species,
  current_subspecies = forestgeo_subspecies,
  current_subspecies_rank = NA,
  current_author = forestgeo_author,
  forestgeochanged = FALSE,
  current_name_notes = "",
  synonyms = NA # the new synonyms after wcvp 
)

```

## Case when no Accepted name was found

Some species are very recent and don't show up in WCVP. We will leave their forestgeo names.

swarsu is a recognized morphospecies that has not yet been fully identified.  It is kept in the list.
```{r speciesrevision2}
species_na_wcvp <- panwoodtaxawcvpplus %>% filter(is.na(wcvp_status))

if(nrow(species_na_wcvp)>0){
  knitr::kable(species_na_wcvp %>% select(sp6, forestgeo_name))
}

leave_orig_name <- species_na_wcvp$forestgeo_name
```


## Case when the species name is accepted but the name spelling differs:

When the wcvp status is Accepted but the name matched by wcvp is different from the accepted name. 

Should only be typos or spelling: In this case the final list will keep the wcvp spelling. 

```{r wcvpmatcherrors, echo=TRUE}
##########   Check for errors while matching (should be just spelling)  

# Matching errors should be only on typos or spelling errors:
# subspecies and hybrids are common errors. 
matchingerrors <- panwoodtaxawcvpplus %>%
  filter((is.na(Name_matched) | forestgeo_name !=Name_matched) & wcvp_status == "Accepted") %>%
  arrange(match_similarity)  %>%
  mutate(row_id = row_number())

# If genus, species or subspecies seem very different (not just spelling). It is probably a mistake
# If the error is a small spelling, leave the name in WCVP (accepted name)
# For the species that the match is weird, lets leave the current name as accepted name.
if(nrow(matchingerrors)>0){
  knitr::kable(matchingerrors %>% select(row_id, forestgeo_name,Name_matched, Accepted_name, match_similarity), caption="The name is accepted but the spelling is a bit difference.")
}
```

In this case all species names seem to have spelling missmatches. If the names are very different it means wcvp might have made a mistake on the match and we should be careful changing that name. 

Here we change the names for those species in the final list to keep the wcvp spelling:
```{r wcvpmatchingerror2}

leave_orig_name_missmatch <- c()
#leave_orig_name_missmatch <- c( ...)

# list of species name that we will change as they have a different spelling
changes_spelling1 <- matchingerrors 
  #filter(!forestgeo_name %in% leave_orig_name_missmatch) %>% # select all the species that have just spelling changes.

inc <- with(panwoodtaxawcvpplus, panwoodtaxawcvpplus$forestgeo_name %in% changes_spelling1$forestgeo_name)


if (any(inc, na.rm=TRUE)) {
  
  tmp <- panwoodtaxawcvpplus[inc, ]
  

  tmp$forestgeochanged <- TRUE

    tmp$current_author  <- ifelse(!is.na(tmp$Accepted_name_author), tmp$Accepted_name_author, tmp$current_author)
  
  tmp$synonyms <- ifelse(is.na(tmp$synonyms) | tmp$synonyms == "", 
                         tmp$forestgeo_name, 
                         paste(tmp$synonyms, tmp$forestgeo_name, sep = "; "))
  
  tmp$current_family     <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$current_family)
  
  tmp$current_genus      <- tmp$Accepted_name_genus
  tmp$current_species    <- tmp$Accepted_name_species
  tmp$current_subspecies <- tmp$Accepted_name_infraspecies
  tmp$current_name       <- tmp$Accepted_name
  tmp$current_subspecies_rank <- tmp$Accepted_name_infraspecific_rank
  tmp$current_name_notes            <- "Spelling changed in wcvp"
  
  # Re-assign the modified subset back to the original rows
  panwoodtaxawcvpplus[inc, ] <- tmp
}
```

Species name spelling modified: `r nrow(changes_spelling1)`

## Cases in which multiple forestgeo species would have the same name under wcvp:

⚠️  This means the species are considered the same under wcvp. 

Because these remain distinct morphospecies in the ForestGEO database, we retain the duplicates, and keep using the ForestGEO name.  


```{r dupsnames, echo=TRUE}

########### Check for duplicate species 

# Two species can now have the same accepted name. 
# One is now considered a synonym or illegitimate and the other is the accepted name
# OR the synonym could be a different species but with a matching error. Lets check. 

acceptednamesdup <- panwoodtaxawcvpplus %>% 
  filter(!is.na(Accepted_name)) %>%
  group_by(Accepted_name) %>% 
  arrange(Accepted_name) %>% filter(n()>1) %>% ungroup() %>%
  mutate(mismatch = (forestgeo_name != Name_matched)) %>% 
  arrange(Accepted_name, mismatch, match_similarity) %>%
  select( sp6, Accepted_name, forestgeo_name, Name_matched, wcvp_status, mismatch, match_similarity )

if( nrow(acceptednamesdup) > 0){
  knitr::kable(acceptednamesdup %>% select(sp6, Accepted_name, forestgeo_name, Name_matched ), caption="Two species have now the same name")
}

```

⚠️ Since they have different codes we leave the species as they are and add a note that they current wcvp names is the same as another species in the list

```{r duplicatedaccepted}

# Lets change the names of the following species: 
dupsynonyms <-  acceptednamesdup %>% filter(wcvp_status != "Accepted") 

leave_orig_name_dups <- dupsynonyms$forestgeo_name

# leave comment for species duplicates
inc <- with(panwoodtaxawcvpplus, (forestgeo_name %in% leave_orig_name_dups))
if (any(inc, na.rm = TRUE)) {
  
  tmp <- panwoodtaxawcvpplus[inc, ]


  # Update notes without overwriting
  tmp$current_name_notes <- "WCVP name is the same as another species in list"
  
  # Re-assign the modified subset back to the original rows
  panwoodtaxawcvpplus[inc, ] <- tmp
}

```


## Case when a name is a synonym and the spelling differs.

Some species are listed as synonyms in WCVP, and that is okay, but first lets check that wcvp didn't make a mistake while matching the species name to the accepted name. Since a mismatch could mean the WCVP matching is not good, and changing the species name can be misleading.

```{r namechanges, echo=TRUE}

# Some species have changed their name, that is normal. Lets check that wcvp didint make a mistake the matching
noacceptedwcvpname <- panwoodtaxawcvpplus %>% 
  filter(
    (is.na(wcvp_status) | wcvp_status != "Accepted") &
      !is.na(forestgeo_name) &
      !is.na(Name_matched) &
      forestgeo_name != Name_matched &
      !forestgeo_name %in% leave_orig_name_dups &
      !forestgeo_name %in% leave_orig_name
  ) %>%
  arrange(wcvp_status, match_similarity) %>%
  mutate(row_id = row_number()) %>%
  select(row_id, forestgeo_name, Name_matched, Accepted_name, wcvp_status, match_similarity) 

if(nrow(noacceptedwcvpname)>0){
  knitr::kable(noacceptedwcvpname, caption="Species where the match is not exact and the name changes")
}

```

The matches are for spelling differences, so nothing to worry about. Just change the name to the WCVP spelling: 
```{r fixspelling2, echo=TRUE, reuslts="hide"}

#leave_orig_name_missmatch <- c(leave_orig_name_missmatch, ...)

# If the matched name is very different needs revision
# otherwise its probably a spelling error, the accepted name is okay
change_spelling2 <- noacceptedwcvpname
  #filter(!forestgeo_name %in% leave_orig_name_missmatch) %>%

inc <- with(panwoodtaxawcvpplus, panwoodtaxawcvpplus$forestgeo_name %in% change_spelling2$forestgeo_name)


if (any(inc, na.rm=TRUE)) {
  tmp <- panwoodtaxawcvpplus[inc, ]
  

  tmp$forestgeochanged <- TRUE

  tmp$current_author  <- ifelse(!is.na(tmp$Accepted_name_author),
                                tmp$Accepted_name_author, 
                                tmp$current_author)
  
  tmp$synonyms <- ifelse(is.na(tmp$synonyms) | tmp$synonyms == "", 
                         tmp$forestgeo_name, 
                         paste(tmp$synonyms, tmp$forestgeo_name, sep = "; "))
  
  tmp$current_family     <- ifelse(!is.na(tmp$Accepted_family),
                                   tmp$Accepted_family, tmp$current_family)
  
  tmp$current_genus      <- tmp$Accepted_name_genus
  tmp$current_species    <- tmp$Accepted_name_species
  tmp$current_subspecies <- tmp$Accepted_name_infraspecies
  tmp$current_name       <- tmp$Accepted_name
  tmp$current_subspecies_rank <- tmp$Accepted_name_infraspecific_rank
  tmp$current_name_notes            <- "Name changed in wcvp"
  
  # Re-assign the modified subset back to the original rows
  panwoodtaxawcvpplus[inc, ] <- tmp
}

```

Species name spelling modified and accepted name also changed: `r nrow(change_spelling2)`


```{r missmatchnote, echo=TRUE}
# Adding a note for species with missmatched names that were left with the forestgeo name

panwoodtaxawcvpplus <- panwoodtaxawcvpplus %>% mutate(
  current_name_notes = ifelse(forestgeo_name %in% leave_orig_name_missmatch, 
                              "WCVP bad match, leaving forestgeo name", current_name_notes)
)


```


## Case when the Family changed

Some species kept the same name but the family they belong to changed!

```{r familychanged2}

familychanged <-  panwoodtaxawcvpplus %>% filter( forestgeo_name == Accepted_name & current_family != Accepted_family &  wcvp_status == "Accepted") 

paste0("Species with changes in family ",  nrow(familychanged))
if( nrow(familychanged) > 0){
  knitr::kable(familychanged %>%  select(forestgeo_family, Accepted_family, forestgeo_name, Accepted_name, wcvp_status, current_name_notes), caption="Species with changes in family")
}

```

Here we modify the species where the family changed:

```{r modifyfamily}
# set family to the accepted family:
inc <- with(panwoodtaxawcvpplus,(
        (!is.na(forestgeo_name) & !is.na(Accepted_name) &  forestgeo_name == Accepted_name &   wcvp_status == "Accepted" & forestgeo_name %in% familychanged$forestgeo_name)))


# Change the species family name
if (any(inc, na.rm = TRUE)) {
  tmp <- panwoodtaxawcvpplus[inc, ]
  
  # Perform calculations on the subset
  tmp$forestgeochanged <- TRUE
  tmp$current_family  <- tmp$Accepted_family
  tmp$current_name_notes  <- "Family changed"
  
  # Re-assign the modified subset back to the original rows
  panwoodtaxawcvpplus[inc, ] <- tmp
}

#sanity check: a single genus always has the same family:
genus_many_families <- panwoodtaxawcvpplus %>%
  group_by(current_name) %>%
  summarise(n_families = n_distinct(current_family), .groups = "drop") %>%
  filter(n_families > 1)


if( nrow(genus_many_families) > 0){
  knitr::kable(genus_many_families %>%  select(current_name, n_families), caption="Sanity check: genus with more than one family")
}

```


## Change species name when the match was perfect and WCVP says it is a synonym or Illegitimate:

Finally we change the current species names to th WCVP accepted name. We only change the species in cases in which:

1. The wcvp status is not accepted AND
2. The name matched by wcvp is exactly the same as the forestgeo name AND
3. The WCVP name is not duplicated within the ForestGEO list (that is, there are not multiple forestgeo taxa that match to the same WCVP name) AND
4. The wcvp name does not delete a subspecies (like Swartzia simplex subspecies)

```{r acceptednamechange }

# if for some reason species name change but should be left alone. 
leave_forestgeo_names = c(
  "Swartzia simplex var. continentalis", # no match with the subspecies
  "Swartzia simplex var. grandiflora",  # no match with the subspecies
  leave_orig_name_dups,
  leave_orig_name,
  leave_orig_name_missmatch
)

species_accepted_changed <- panwoodtaxawcvpplus %>% filter(
        (!is.na(forestgeo_name) & !is.na(Name_matched) & forestgeo_name == Name_matched & wcvp_status != "Accepted") &
        (!is.na(forestgeo_name) & !forestgeo_name  %in% leave_forestgeo_names)
)
  

if(nrow(species_accepted_changed) > 0){
   knitr::kable(species_accepted_changed %>% select(forestgeo_name, Name_matched, Accepted_name, wcvp_status), caption="Species name changed.")
}

```

```{r acceptednamechanged2}
# changing the species

inc <- with(panwoodtaxawcvpplus,
        forestgeo_name %in% species_accepted_changed$forestgeo_name)

if (any(inc, na.rm = TRUE)) {
  tmp <- panwoodtaxawcvpplus[inc, ]
  

  tmp$forestgeochanged <- TRUE

  tmp$current_author  <- ifelse(!is.na(tmp$Accepted_name_author),
                                tmp$Accepted_name_author, 
                                tmp$current_author)
  
  tmp$synonyms <- ifelse(is.na(tmp$synonyms) | tmp$synonyms == "", 
                         tmp$forestgeo_name, 
                         paste(tmp$synonyms, tmp$forestgeo_name, sep = "; "))
  
  tmp$current_family     <- ifelse(!is.na(tmp$Accepted_family),
                                   tmp$Accepted_family, tmp$current_family)
  
  tmp$current_genus      <- tmp$Accepted_name_genus
  tmp$current_species    <- tmp$Accepted_name_species
  tmp$current_subspecies <- tmp$Accepted_name_infraspecies
  tmp$current_name       <- tmp$Accepted_name
  tmp$current_subspecies_rank <- tmp$Accepted_name_infraspecific_rank
  tmp$current_name_notes   <- paste0("Previous Species name was ", tmp$wcvp_status, " - Name changed in wcvp")
  
  # Re-assign the modified subset back to the original rows
  panwoodtaxawcvpplus[inc, ] <- tmp
}

```

## Sanity check:
```{r speciesrevision}

# species that remain with a different name form wcvp
species_no_wcvp <- panwoodtaxawcvpplus %>% filter(is.na(current_name) | is.na(wcvp_name) | current_name!=wcvp_name)

paste0("Species were accepted name is still different from wcvp: ",nrow(species_no_wcvp))
if( nrow(species_no_wcvp) > 0){
  knitr::kable(species_no_wcvp %>%  select(sp6, current_name, wcvp_name,  current_family, wcvp_family, wcvp_status, Name_matched, current_name_notes), caption="Species were name is still different from wcvp accepted name")
}


# species with duplicated current name
acceptednamesdup <- panwoodtaxawcvpplus %>% 
  filter(!is.na(current_name)) %>%
  group_by(current_name) %>% 
  arrange(current_name) %>% filter(n()>1) %>% ungroup() %>%
  mutate(mismatch = (forestgeo_name != Name_matched)) %>% 
  arrange(current_name, mismatch, match_similarity) %>%
  select( sp6, current_name, forestgeo_name, Name_matched, wcvp_status, mismatch, match_similarity )

if( nrow(acceptednamesdup) > 0){
  knitr::kable(acceptednamesdup,caption="Duplicated species")
}


```

## Check for missing information and consistency

The Unplaced  status can have missing information. 

```{r checkmissing, echo=TRUE}

missing_info <- panwoodtaxawcvpplus %>% filter(
  (!is.na(current_name ) & word(current_name, 1) != current_genus) |
  is.na(current_genus) | is.na(current_family) | is.na(current_author) | is.na(current_species))   


datatable(
  missing_info %>% select(sp6, current_name, forestgeo_name, current_species, 
         forestgeo_species, current_genus, forestgeo_genus,
         current_family, forestgeo_family, current_author, 
         forestgeo_author, forestgeochanged, wcvp_status, current_name_notes),
  caption = "Species with missing taxonomic information in wcvp",
  options = list(scrollX = TRUE, pageLength = 10),
  rownames = FALSE
)

```

```{r setgenus}
# To fix this set genus in name as genus
panwoodtaxawcvpplus <- panwoodtaxawcvpplus %>% 
  mutate(current_genus  = word(current_name, 1),
         current_species  = word(current_name, 2))

# keep the columns

panwoodtaxaout <- panwoodtaxawcvpplus %>%
  select(
    -Name_matched_rank, 
    -wcvp_authors, 
    -Accepted_name,
    -Accepted_family, 
    -Accepted_name_rank, 
    -Accepted_name_author, 
    -Accepted_name_status, 
    -Accepted_name_genus, 
    -Accepted_name_species, 
    -Accepted_name_infraspecific_rank, 
    -Accepted_name_infraspecies, 
    -match_similarity, 
    -match_edit_distance
  ) %>% rename(
    wcvp_lifeform_description = lifeform_description,
    wcvp_Name_matched = Name_matched,
    forestgeo_habit = habit
  )


```


# Add sp4 codes from Wright list
Now we add the sp4 codes to our species list. This codes are in the Wright list. 

We match the sp4 code by:
(1) on sp6 code
(2) on forestgeo / original name 
(3) on accepted name (from WCVP) 

Output the number of species matched on 1 alone, on 2 but not 1, and on 3 but not 2 or 1. 

```{r sp4check, echo=TRUE}

# add sp4 codes from Wright list
wright_no_sp6 <- usewrighttaxa %>% 
  anti_join(panwoodtaxaout, by = "sp6")

wright_no_sp6_noorigname <- wright_no_sp6 %>% 
  anti_join(panwoodtaxaout, by = c("orig_name" = "forestgeo_name"))

# 2. Matching with index protection
panwoodtaxaout <- panwoodtaxaout %>%
  mutate(
    m1_idx = match(sp6, usewrighttaxa$sp6),
    m2_idx = ifelse(is.na(m1_idx), match(forestgeo_name, wright_no_sp6$orig_name), NA),
    m3_idx = ifelse(is.na(m1_idx) & is.na(m2_idx), match(current_name, wright_no_sp6_noorigname$current_name), NA),
    
    # Use the specific dataframes for each index
    sp4 = case_when(
      !is.na(m1_idx) ~ usewrighttaxa$sp4[m1_idx],
      !is.na(m2_idx) ~ wright_no_sp6$sp4[m2_idx],
      !is.na(m3_idx) ~ wright_no_sp6_noorigname$sp4[m3_idx], # Fixed reference
      TRUE ~ NA_character_
    )
  )

resumen_matches <- panwoodtaxaout %>%
  summarise(
    M1_sp6 = sum(!is.na(m1_idx)),
    M2_orig_name = sum(!is.na(m2_idx)),
    M3_current_name = sum(!is.na(m3_idx)),
    No_Match = sum(is.na(sp4))
  ) %>%
  tidyr::pivot_longer(everything(), names_to = "Matching Step", values_to = "Count")

# Imprimimos la tabla con kable
knitr::kable(resumen_matches, 
      caption = "Summary of Species Matching Results (M1, M2, M3)")

panwoodtaxaout <- panwoodtaxaout %>% select(-m1_idx, -m2_idx, -m3_idx)
```

Identify inconsistencies
```{r fixspecialsp4,  echo=TRUE, results="hide"}

# 1. Identify duplicated sp4 codes
usage_frequency <- panwoodtaxaout %>%
  filter(!is.na(sp4)) %>%
  count(sp4, name = "occurrence_count") %>%
  count(occurrence_count, name = "number_of_sp4_codes")

print(usage_frequency)

# 2. Identify, Join, and Display Duplicates
panwoodtaxaout %>%
  # Filter only for rows where the sp4 is duplicated
  group_by(sp4) %>%
  filter(n() > 1 & !is.na(sp4)) %>%
  ungroup() %>%
  # Join with Wright list to see their side of the story
  left_join(
    usewrighttaxa %>% select(sp4, wcvp_name_wright = current_name, sp6_wright = sp6),
    by = "sp4"
  ) %>%
  # Organize and Select columns for the final table
  select(sp4, sp6, current_name, forestgeo_name, wcvp_name, wcvp_name_wright, sp6_wright) %>%
  arrange(sp4) %>%
  knitr::kable(caption = "Species sharing the same sp4 code (compared with Wright List)") 

# 3. Check for NAs (Species that failed all 3 match steps)
na_count <- sum(is.na(panwoodtaxaout$sp4))
matched_count <- sum(!is.na(panwoodtaxaout$sp4))



```


`r paste(sum(!is.na(panwoodtaxaout$sp4)), "/", nrow(panwoodtaxaout))` woody taxa were successfully assigned a sp4 code.



# Save files -> combined panama woody, changes in panama woody, sp4 codes that need revision:

```{r finaloutput}

species_modified <- panwoodtaxaout %>% filter( forestgeochanged == TRUE) %>% arrange(current_name_notes, forestgeo_name)

paste0("Total of species modified: ",  nrow(species_modified))
if( nrow(species_modified) > 0){
  datatable(species_modified %>%  select(sp6,  current_name, forestgeo_name, wcvp_name, current_family, forestgeo_family,  wcvp_family,  wcvp_status, current_name_notes), caption="Species modified after matching with WCVP", options = list(scrollX = TRUE, pageLength = 10))
}



if(FIX_SPECIES){
  
write_xlsx(panwoodtaxaout, PANAMA_COMBINED_OUT_PATH)
  
write_xlsx(species_modified, PANAMA_COMBINED_CHANGE_SUMMARY_PATH)
  
 }

```

# Synonyms and alternate names file

```{r synonyms}

alternate_synonym_table <- panwoodtaxaout %>%

  mutate(OriginalOrder = row_number()) %>%
  
  select(
    OriginalOrder, 
    sp6, sp4, current_name, forestgeo_name, wcvp_name, 
    SynonymTextALL = forestgeo_synonyms
  ) %>%
  
  # Filter out empty synonym rows
  filter(!is.na(SynonymTextALL) & SynonymTextALL != "") %>%

  mutate(SynonymTextSingle = SynonymTextALL) %>%
  separate_longer_delim(SynonymTextSingle, delim = ",") %>%
  mutate(SynonymTextSingle = trimws(SynonymTextSingle)) %>%
  
  # Order of the synonym in the original text
  group_by(OriginalOrder) %>%
    mutate(SynonymNumber = row_number()) %>%
    ungroup() %>%
  
  # 6. Extract Genus and Species from the single synonym
  # Using too_many="merge" in case there are infraspecific names
  separate_wider_delim(
    SynonymTextSingle, 
    delim = " ", 
    names = c("SynonymGenusSingle", "SynonymSpeciesSingle"),
    too_many = "merge",
    cols_remove = FALSE
  ) %>% arrange(current_name)

# View the result
datatable(alternate_synonym_table, 
             caption = "Mapping: Original Name to Individual Synonym",
          options = list(scrollX = TRUE, pageLength = 10))

# make a file that gives the synonyms as 1-to-1 list
if(FIX_SPECIES){
  write_xlsx(alternate_synonym_table, FNSYNONYMS)
}

```


```{r sp4missing}
# 4. Find codes in Wright list NOT present in the woody list AND 
# and that DO have #1 in any of the following columns: tree, midstory, understory, shrub, liana.  Include a column for their lifeform according to Wright (based on these columns)
 
missing_from_wright <- usewrighttaxa %>%
  filter(!sp4 %in% panwoodtaxaout$sp4 &
        ((!is.na(tree) & tree != 0) | 
        (!is.na(midstory) & midstory != 0) | 
        (!is.na(understory) & understory != 0) | 
        (!is.na(shrub) & shrub != 0) | 
        (!is.na(liana) & liana != 0) )) %>%
  mutate(
    synonym_match_name = case_when(
      current_name %in% alternate_synonym_table$SynonymTextSingle ~ current_name,
      orig_name %in% alternate_synonym_table$SynonymTextSingle ~ orig_name,
      TRUE ~ NA_character_
    ),
    is_alternate_name = !is.na(synonym_match_name),

lifeform_wright = paste(
      if_else(!is.na(tree) & tree != 0, "TREE", "_"),
      if_else(!is.na(midstory) & midstory != 0, "MIDSTORY", "_"),
      if_else(!is.na(understory) & understory != 0, "UNDERSTORY", "_"),
      if_else(!is.na(shrub) & shrub != 0, "SHRUB", "_"),
      if_else(!is.na(liana) & liana != 0, "LIANA", "_"), # No longer breaks!
      if_else(!is.na(climber) & climber != 0, "CLIMBER", "_"),
      if_else(!is.na(free) & free != 0, "FREE", "_"),
      if_else(!is.na(vine) & vine != 0, "VINE", "_"),
      if_else(!is.na(herb) & herb != 0, "HERB", "_"),
      if_else(!is.na(epiphyte) & epiphyte != 0, "EPIPHYTE", "_"),
      if_else(!is.na(hemiepiphyte) & hemiepiphyte != 0, "HEMIEPIPHYTE", "_"),
      if_else(!is.na(parasite) & parasite != 0, "PARASITE", "_"),
      sep = ", "
    ),
    
    # 2. Remove the underscores and extra commas
    # This regex looks for "_" followed by a comma or a comma followed by "_"
    lifeform_wright = str_remove_all(lifeform_wright, "_, | ,_|_"),
    
    # 3. Final polish to remove any leading/trailing commas or spaces
    lifeform_wright = str_trim(str_remove_all(lifeform_wright, "^, |, $")),
    
    # 4. If nothing is left, make it a true NA
    lifeform_wright = if_else(lifeform_wright == "", NA_character_, lifeform_wright)
) %>%
  left_join(alternate_synonym_table %>% select(SynonymTextSingle, forestgeo_name, OriginalOrder),by=c("synonym_match_name" = "SynonymTextSingle")) %>%
  rename(
    forestgeo_synonym_source = forestgeo_name
  )


datatable(missing_from_wright %>% select(sp4, sp6, orig_name, current_name, is_alternate_name, forestgeo_synonym_source, lifeform_wright),
          caption = "Wright codes not used in PanWood",
          options = list(scrollX = TRUE, pageLength = 10))

write_xlsx(missing_from_wright, WRIGHT_MISSING_PANWOODY_PATH)
```

# Higher level taxa:

The correct names should be under the prefix currwcvp_ 

```{r checkhigher, echo=TRUE, results="hide"}

allsp <- panwoodtaxaout # the fixed list

# currwcvp_name is now the correct name, based on the fixes previously done. 
allsp <- allsp %>% mutate(
       genus = current_genus,
       family = current_family,
       genuscode=ifelse(is.na(sp6),NA,substr(sp6,1,4)))

# check that a single genus always has the same family:
genus_check1 <- allsp %>%
  group_by(genus) %>%
  summarise(n_families = n_distinct(family), .groups = "drop") %>%
  filter(n_families > 1)
genus_check1

# check whether a single genus always has the same lifeform:
genus_check2 <- allsp %>%
  group_by(genus) %>%
  summarise(
    habit_class = case_when(
      n_distinct(forestgeo_habit) == 1 & first(forestgeo_habit) == "Climbing"     ~ "Climbing only",
      n_distinct(forestgeo_habit) == 1 & first(forestgeo_habit) == "Freestanding" ~ "Freestanding only",
      n_distinct(forestgeo_habit)  > 1                                  ~ "Both"
    ),
    .groups = "drop"
  ) %>%
  count(habit_class, name = "n_genera")
genus_check2

# to print genus and species with different habits
genera_both <- allsp %>%
  group_by(genus) %>%
  filter(n_distinct(forestgeo_habit) > 1) %>%
  ungroup()

table_2rows <- genera_both %>%
  group_by(genus, forestgeo_habit) %>%
  summarise(
    Species = paste(sort(unique(current_name)), collapse = ", "),
    .groups = "drop"
  ) %>%
  arrange(genus, forestgeo_habit)


# check that a single genus always has the same first 4 letters of species code:
genus_check3 <- allsp %>%
  group_by(genus) %>%
  summarise(n_genuscode = n_distinct(genuscode), 
            genuscode_list = paste(sort(unique(genuscode)), collapse = ", "),
            .groups = "drop") %>%
  filter(n_genuscode > 1)
genus_check3

# find cases where same genuscode corresponds to more than 1 Accepted genus
genus_check4 <- allsp %>%
  group_by(genuscode) %>%
  summarise(
    Accepted_gen4_list = paste(sort(unique(substr(genus,1,4))),collapse=", "),
    Accepted_gen3_list = paste(sort(unique(substr(genus,1,3))),collapse=", "),
    n_Accepted_genus = n_distinct(genus),
    Accepted_genus_list = paste(sort(unique(genus)), collapse = ", "),
    .groups = "drop"
  ) %>%
  filter(n_Accepted_genus > 1)
genus_check4


# just get cases in which there are multiple genus names that have the same first 3 letters as the genus code:  
genus_check5 <- allsp %>%
  filter(!is.na(genuscode)) %>%
  mutate(prefix3 = substr(genuscode, 1, 3),
         genus_prefix3 = tolower(substr(genus, 1, 3))) %>%
  # keep only genus names matching the first 3 letters of genuscode
  filter(genus_prefix3 == prefix3) %>%
  group_by(genuscode) %>%
  summarise(
    n_distinct_genus = n_distinct(genus),
    Accepted_genus_list = paste(sort(unique(genus)), collapse = ", "),
    .groups = "drop"
  ) %>%
  filter(n_distinct_genus > 1) %>%
  arrange(genuscode)
genus_check5

# i changed this, the previous version could count species twice in different genus
genusdfall <- allsp %>%
  group_by(genus) %>%
  summarize(nsptree=sum(forestgeo_habit=="Freestanding"),
            nspliana=sum(forestgeo_habit=="Climbing")) %>%
  ungroup() %>% 
  mutate(Accepted_name=genus,
         Accepted_name_rank="genus")  %>%
  dplyr::select(Accepted_name,Accepted_name_rank,nsptree,nspliana)

#sanity check
sum(genusdfall$nspliana + genusdfall$nsptree)
nrow(allsp)

familydfall <- allsp %>%
  group_by(family) %>%
  summarize(nsptree=sum(forestgeo_habit=="Freestanding"),
            nspliana=sum(forestgeo_habit=="Climbing")) %>%
  ungroup() %>% 
  mutate(Accepted_name=family,
         Accepted_name_rank="family")  %>%
  dplyr::select(Accepted_name,Accepted_name_rank,nsptree,nspliana)

#sanity check
sum(familydfall$nspliana + familydfall$nsptree)
nrow(allsp)

# Merge genus and family in higher taxa
allhighertaxa <- rbind(genusdfall,familydfall) %>%
  mutate(lifeform=paste0(ifelse(nsptree>0,"A",""),ifelse(nspliana>0,"L",""))) %>%
  dplyr::select(Accepted_name,Accepted_name_rank,lifeform)

```
Checking consistency in higher taxa: 

1. Genus names related to more than 1 family: `r nrow(genus_check1)`

```{r genuscheck1}
if (nrow(genus_check1) > 0) { 
  datatable(genus_check1, caption="Genus with more than 1 family",
            options = list(scrollX = TRUE, pageLength = 10))
} 
```

2. Genus with species with different life forms: `r nrow(genus_check2$n_genera[genus_check2$habit_class == "Both"])` 

```{r genuscheck2}
if (nrow(genus_check2) > 0) { 
  datatable(genus_check2, caption="Genus lifeform. Check wether a single genus always has the same life form", options = list(scrollX = TRUE, pageLength = 10))
} 

if(genus_check2$n_genera[genus_check2$habit_class == "Both"] > 0){
  datatable(table_2rows, caption="Genus with species with two life forms",options = list(scrollX = TRUE, pageLength = 10))
}
```

3. Codes that don't match genus (probably because of name changes): `r nrow(genus_check3)`

```{r genuscheck3}
if (nrow(genus_check3) > 0) { 
  datatable(head(genus_check3, 10), caption="Genus with codes that dont match genus name",options = list(scrollX = TRUE, pageLength = 10))
} 
```

4. Codes that match to more than one genus (probably because of name changes): `r nrow(genus_check4)`

```{r genuscheck4}
if (nrow(genus_check4) > 0) { 
  datatable(head(genus_check4, 10), caption="Genus with codes that match more than one genus",options = list(scrollX = TRUE, pageLength = 10))
} 
```


5. Genus code matches genus but is present in more than one genus (probably because of name changes): `r nrow(genus_check5)`

```{r genuscheck5}
if (nrow(genus_check5) > 0) { 
  datatable(head(genus_check5,10), caption="Genus with the same 3 letters of code",options = list(scrollX = TRUE, pageLength = 10))
} 
```

## Write taxa summary

```{r taxasummary, echo=TRUE, results="hide"}

spdfall <- allsp %>%
  mutate(lifeform=ifelse(forestgeo_habit=="Freestanding","A","L"),
         Accepted_name_rank = "species") %>%
  select(current_name,sp6,sp4,Accepted_name_rank,lifeform) %>%
  rename(Accepted_name=current_name,sp6=sp6)

outtaxa <- bind_rows(spdfall,allhighertaxa) %>%
  rename(namerank=Accepted_name_rank,taxaname=Accepted_name) %>%
  arrange(taxaname)

table(outtaxa$namerank)

if(FIX_SPECIES){
  write_xlsx(outtaxa,FNPANAMATAXA)
}
```

