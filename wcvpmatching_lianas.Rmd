---
title: "wcvp_name_matching"
author: "Paula Uzcategui"
date: "2026-02-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Match WCVP names with species name

Next we do:

Input: list of species

- Match wcvp names
- Trying to be careful with species missmatches. Changing a species name when the match is not perfect needs manual verification.
- After the update two species can have the same wcvp name. Duplicates are removed but their original name is kept in a synonyms column.


Output: 

- _WCVP file with the original species list columns and the columns from wcvp
- _WCVP_CHANGES a file containing only the species were the original name changed in respect to the wcvp name. 

```{r setup2, echo=TRUE,message=FALSE, warning=FALSE, results="hide"}

# installing wcvp
#install.packages("remotes")
#library(remotes)
#remotes::install_github("matildabrown/rWCVP")
#rm(list=ls())

library("readxl")
library("writexl")
library("dplyr")
library("tidyr")
library("stringr")
suppressPackageStartupMessages({
  library(rWCVP)
  library(rWCVPdata)
})
library(DT)

citation("rWCVPdata") # according to this, this is using version 13.

# Load WCVP backbone
wcvp_names <- rWCVPdata::wcvp_names 

# INPUT PATHS
original_list_path <- "splists_raw/Schnitzer/Lianas_Species_complete_list_2026-02-13.xlsx"

# Extract file name without extension 
original_list_name <- tools::file_path_sans_ext(basename(original_list_path))

# Path for intermediate matching results (to skip heavy processing if already done)
matches_mid_path <- paste0("splists_mid/", original_list_name, "_mid_match.rds")

# OUTPUT PATHS 
out_wcvp_list <- paste0("splists_out/", original_list_name, "_WCVP_", Sys.Date(), ".xlsx")
out_wcvp_changes_list <- paste0("splists_out/", original_list_name, "_WCVP_CHANGES_", Sys.Date(), ".xlsx")



```

## Prepare datasets
```{r preparedata, echo=TRUE, results="hide"}

#origlist <- read.csv(original_list_path)
lianas <- read_excel(original_list_path)
l1 <- lianas$`List 1`
l2 <- lianas$`List 2`
lianaslist <- data.frame(codename = c(l1,l2))
origlist <- lianaslist %>% 
  filter(!is.na(codename) & codename!="Desconocida") %>%
  separate(codename, into = c("code", "name"), sep = " - ", remove = FALSE)%>%
  mutate(sp = str_trim(code) %>% str_to_lower(),
         liana_name = str_trim(name) %>% str_to_sentence()) %>%
  select(-code, -name)

# keep unique sp + liana
origlist <- origlist %>% 
  distinct(sp, liana_name, .keep_all = TRUE)


# modify this depending on the original dataset. 
origlist <- origlist %>%
  mutate(
    orig_family = NA,
    orig_genus = word(liana_name, 1),
    orig_species = word(liana_name, 2),
    orig_author = NA,
    orig_infrasp_rank = NA,
    orig_infraspecies = NA
  ) %>% 
 rename(
   orig_name = liana_name
 )%>%
  arrange(orig_name)


# remove duplicates
dups <- origlist %>% group_by(orig_name) %>% filter(n() > 1) %>% select(sp, orig_name, codename)

if(nrow(dups) > 0){
  knitr::kable(dups, caption="Duplicated names")
}

origlist <- origlist %>% group_by(orig_name) %>% filter(n() == 1) %>% ungroup()
  
print(paste0("working with ", nrow(origlist), " species"))
```

 
### Match WCVP names

```{r mergewcvp}
######################### PANMA BIOTA WCVP names ##################################

# Helper function to merge and format accepted names from WCVP backbone
matchaccepted_names <- function(matcheswcvp, wcvp_backbone){
  matcheswcvp %>% 
    left_join(wcvp_backbone %>% 
                select(plant_name_id, genus, species, taxon_rank, family, 
                       primary_author, infraspecific_rank, infraspecies, 
                       lifeform_description, taxon_status),
              by = c("wcvp_accepted_id" = "plant_name_id")) %>% 
    mutate(
      Accepted_name = case_when(
        is.na(species) | species == "" ~ genus,
        !is.na(infraspecies) & infraspecies != "" ~ paste(genus, species, infraspecific_rank, infraspecies),
        TRUE ~ paste(genus, species))
    ) %>%
    rename(
      Accepted_family = family,
      Accepted_name_rank = taxon_rank,
      Accepted_name_author = primary_author,
      Accepted_name_status = taxon_status,
      Accepted_name_genus = genus, 
      Accepted_name_species = species, 
      Accepted_name_infraspecific_rank = infraspecific_rank, 
      Accepted_name_infraspecies = infraspecies
    )
}

# --- 1. Run or Load Match ---
if(file.exists(matches_mid_path)){
  matchresult <- readRDS(matches_mid_path)
} else {
  # Run the matching process
  matchresult <- wcvp_match_names(origlist, wcvp_names, name_col = "orig_name")

  # Save as RDS for speed
  saveRDS(matchresult, matches_mid_path)
}

# --- 2. Sanity Checks & Duplicate Resolution ---
# Ensure all species are accounted for
stopifnot(all(origlist$orig_name %in% matchresult$orig_name))

# Identify names that mapped to multiple 'Accepted' records
manyaccepted <- matchresult %>%
  group_by(orig_name) %>%
  filter(sum(wcvp_status == "Accepted", na.rm = TRUE) > 1) %>%
  ungroup()

# If duplicates exist, force use of the original ID to avoid grouping explosion
if (nrow(manyaccepted) > 0) {
  matchresult <- matchresult %>%
    mutate(wcvp_accepted_id = ifelse(orig_name %in% manyaccepted$orig_name, wcvp_id, wcvp_accepted_id))
}

# --- 3. Clean Match Results (1 row per species) ---
matchresult_clean <- matchresult %>%
  mutate(
    status_priority = case_when(
      wcvp_status == "Accepted"     ~ 1,
      wcvp_status == "Synonym"      ~ 2,
      wcvp_status == "Illegitimate" ~ 3,
      wcvp_status == "Unplaced"     ~ 4,
      TRUE                          ~ 5
    )
  ) %>%
  group_by(orig_name) %>%
  slice_min(status_priority, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  matchaccepted_names(wcvp_names)

# --- 4. Final Join and Rename ---
# This merges the WCVP data back into your processed original list
processlist <- origlist %>%
  left_join(matchresult_clean %>% 
              select(orig_name, wcvp_name, wcvp_authors, wcvp_rank, wcvp_status, 
                     Accepted_name, Accepted_family, Accepted_name_rank, 
                     Accepted_name_author, Accepted_name_status, Accepted_name_genus,
                     Accepted_name_species, Accepted_name_infraspecific_rank, 
                     Accepted_name_infraspecies, lifeform_description, 
                     match_similarity, match_edit_distance),
            by = "orig_name") %>%
  rename(
    Name_matched = wcvp_name,
    Name_matched_rank = wcvp_rank
  )

# --- 5. Handle missing matches ---
# If WCVP didn't find a match, we keep the original name as the 'Accepted' placeholder
inc <- is.na(processlist$Accepted_name) | processlist$Accepted_name == ""

if (any(inc, na.rm = TRUE)) {
  processlist$Accepted_name[inc] <- processlist$orig_name[inc]
  processlist$Accepted_name_author[inc] <- processlist$orig_author[inc]
}

# Review Results
processlist %>% count(wcvp_status)


```

## Fix synonims and errors:

```{r checkerrors, echo=TRUE, results="hide"}

# For now lets assume the original name is correct 
processlist <- processlist %>% mutate(
  wcvp_name = orig_name,
  wcvp_family = str_to_sentence(orig_family),
  wcvp_genus = orig_genus,
  wcvp_species = orig_species,
  wcvp_author = orig_author,
  wcvp_infraspecies = orig_infraspecies,
  wcvp_infrasp_rank = orig_infrasp_rank,
  origchanged = FALSE,
  wcvpnotes = "",
  wcvpsynonyms = "",
  sourcesynonyms = ""
)

library(stringi)

# Clean the SYNONYMS column and any other character columns
processlist <- processlist %>%
  mutate(across(where(is.character), ~ stri_encode(., from = NULL, to = "UTF-8"))) %>%
  mutate(across(where(is.character), ~ stri_trans_general(., "latin-ascii"))) # Optional: removes accents

```

### Case when no accepted name was found
```{r noaccepted}

species_na_wcvp <- processlist %>% filter(is.na(wcvp_status))

if(nrow(species_na_wcvp)>0){
  knitr::kable(species_na_wcvp %>% select( orig_name, codename))
}


```

### Case when species name spelling changed

```{r spellingerror}
# Identifying typos or spelling errors
# We filter for cases where the name matched is different from original but is considered 'Accepted'
matchingerrors <- processlist %>%
  filter((is.na(Name_matched) | orig_name != Name_matched) & wcvp_status == "Accepted") %>%
  arrange(match_similarity)  %>%
  mutate(row_id = row_number())

# Display the potential spelling errors
if(nrow(matchingerrors) > 0){
    datatable(
    matchingerrors %>% select(row_id, orig_name, Name_matched, Accepted_name, match_similarity),
    caption = "Potential spelling errors: Name is accepted but differs from original.",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```


```{r spellfix}
# Manual selection of rows that are definitely spelling errors
# ADJUST THE Species based on your new matchingerrors table. 
# The idea is to leave out the species were the orig_name and the Naame matched clearly dont match

leave_out <- c(
  "Chondodendron tomentosum"
)

# change name to the correct spelling of the species that are not in that list
changes_spelling1 <- matchingerrors %>%
  filter(!orig_name %in% leave_out) %>% 
  select(orig_name, Accepted_name)

# Create index for the main dataset
inc <- with(processlist, orig_name %in% changes_spelling1$orig_name)

# Review the subset to be modified
species_modified1 <- processlist[inc, ]

if(nrow(species_modified1) > 0){
  datatable(
    species_modified1 %>% select(orig_name, Name_matched, Accepted_name, match_similarity), 
    caption = "Spelling errors confirmed for correction.",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

# Apply the updates to the main processlist
if (any(inc, na.rm = TRUE)) {
  
  tmp <- processlist[inc, ]
  
  # Update logical flag and metadata
  tmp$origchanged  <- TRUE

  new_comment <- "Spelling changed in WCVP"
  
  # Update notes without overwriting
  tmp$wcvpnotes <- ifelse(is.na(tmp$wcvpnotes) | tmp$wcvpnotes == "", 
                          new_comment, 
                          paste(tmp$wcvpnotes, new_comment, sep = " | "))
  
  # Update taxonomy using the Accepted Name data from WCVP
  tmp$wcvp_author  <- ifelse(!is.na(tmp$Accepted_name_author), tmp$Accepted_name_author, tmp$wcvp_author)
  tmp$wcvp_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$wcvp_family)
  tmp$wcvp_genus   <- tmp$Accepted_name_genus
  tmp$wcvp_species <- tmp$Accepted_name_species
  tmp$wcvp_name    <- tmp$Accepted_name
  tmp$wcvp_infraspecies <- tmp$Accepted_name_infraspecies
  tmp$wcvp_infrasp_rank <- tmp$Accepted_name_infraspecific_rank
  
  # Keep original name in synonyms for traceability
  # Logic: If synonyms is empty, just add name. If not, append with separator.
  tmp$wcvpsynonyms <- ifelse(is.na(tmp$wcvpsynonyms) | tmp$wcvpsynonyms == "", 
                             tmp$orig_name, 
                             paste(tmp$wcvpsynonyms, tmp$orig_name, sep = "; "))
  
  # Re-assign the modified subset back to the original rows
  processlist[inc, ] <- tmp
}
```

# Case when match is not perfect and species name has changed.
```{r noperfectchange}

# Filter for species where match isn't exact and status isn't Accepted
noacceptedwcvpname <- processlist %>% 
  filter(
    (is.na(wcvp_status) | wcvp_status != "Accepted") &
      !is.na(orig_name) &
      !is.na(Name_matched) &
      orig_name != Name_matched
  ) %>%
  arrange(wcvp_status, match_similarity) %>%
  mutate(row_id = row_number()) %>%
  select(row_id, orig_name, Name_matched, Accepted_name, wcvp_status, match_similarity) 


if(nrow(noacceptedwcvpname) > 0){
  datatable(
    noacceptedwcvpname, caption = "Species where the match is not exact and the name changes",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}
```


```{r noperfechchangefix}

# the subspecies doenst match well since i dont want to lose information i will leave it like the original name
leave_out_orig_name2 <- c(
  "Bauhinia sp")


# Select the row IDs that you have verified are correct spelling/name updates
# Note: Ensure these IDs match the table generated above
change_name2 <- noacceptedwcvpname %>%
  filter(!orig_name %in% leave_out_orig_name2) %>%
  select(orig_name, Accepted_name)

# Indexing the main processlist
inc <- with(processlist, orig_name %in% change_name2$orig_name)

# Display what will be modified
if (any(inc, na.rm = TRUE)) {
  species_modified2 <- processlist[inc,]
  
  datatable(
    species_modified2 %>% select(orig_name, Name_matched, Accepted_name, match_similarity), 
    caption = "Confirmed name changes (Keeping Accepted Name)",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
  
  # Update the main list using the subset logic
  tmp <- processlist[inc, ]
  
  tmp$origchanged  <- TRUE
  tmp$wcvp_author  <- ifelse(!is.na(tmp$Accepted_name_author), tmp$Accepted_name_author, tmp$wcvp_author)
  tmp$wcvp_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$wcvp_family)
  
  # Concatenate synonyms safely
  tmp$wcvpsynonyms <- ifelse(is.na(tmp$wcvpsynonyms) | tmp$wcvpsynonyms == "", 
                             tmp$orig_name, 
                             paste(tmp$wcvpsynonyms, tmp$orig_name, sep = "; "))
  
  tmp$wcvp_genus   <- tmp$Accepted_name_genus
  tmp$wcvp_species <- tmp$Accepted_name_species
  tmp$wcvp_name    <- tmp$Accepted_name
 
  tmp$wcvp_infraspecies <- tmp$Accepted_name_infraspecies
  tmp$wcvp_infrasp_rank <- tmp$Accepted_name_infraspecific_rank
  
  new_comment <-  paste0("Imperfect match | Previous name was ", tmp$wcvp_status, " - Name changed in WCVP")
  
  # Update notes without overwriting
  tmp$wcvpnotes <- ifelse(is.na(tmp$wcvpnotes) | tmp$wcvpnotes == "", 
                          new_comment, 
                          paste(tmp$wcvpnotes, new_comment, sep = " | "))
  
  # Re-assign subset back to original
  processlist[inc, ] <- tmp
}

```



## Change species name when the match was perfect and WCVP reported a name change:
```{r seechamngenames}


# Identify species where the match was perfect but status is NOT 'Accepted'
species_accepted_changed <- processlist %>% 
  filter(
    !is.na(orig_name) & 
    !is.na(Name_matched) & 
    orig_name == Name_matched & 
    wcvp_status != "Accepted"
  )

if(nrow(species_accepted_changed) > 0){
  datatable(
    species_accepted_changed %>% select(orig_name, Name_matched, Accepted_name, wcvp_status), 
    caption = "Species matched perfectly but status is not 'Accepted' (Synonyms/Illegitimate).",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}


```

```{r fixchangenames}
# Now the species names we would like to change:
# No missmatch between Name_matched and Current_name and The state is non accepted.

# Manual list of species to protect (do not update these even if WCVP suggests a change)
leave_orig_names = c(
)

# Define the logical index for the changes
inc <- with(processlist, (
  !is.na(orig_name) & 
  !is.na(Name_matched) & 
  orig_name == Name_matched & 
  wcvp_status != "Accepted" &
  !(orig_name %in% leave_orig_names)
))

if (any(inc, na.rm = TRUE)) {
  
  tmp <- processlist[inc, ]
  
  # Update internal flags
  tmp$origchanged <- TRUE
  
  # Update synonyms: Add original name to the history
  tmp$wcvpsynonyms <- ifelse(is.na(tmp$wcvpsynonyms) | tmp$wcvpsynonyms == "", 
                             tmp$orig_name, 
                             paste(tmp$wcvpsynonyms, tmp$orig_name, sep = "; "))
  
  # Update taxonomy to the new Accepted Name details
  tmp$wcvp_author  <- ifelse(!is.na(tmp$Accepted_name_author), tmp$Accepted_name_author, tmp$wcvp_authors)
  tmp$wcvp_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$wcvp_family)
  tmp$wcvp_genus   <- tmp$Accepted_name_genus
  tmp$wcvp_species <- tmp$Accepted_name_species
  tmp$wcvp_name    <- tmp$Accepted_name
  tmp$wcvp_infraspecies <- tmp$Accepted_name_infraspecies
  tmp$wcvp_infrasp_rank <- tmp$Accepted_name_infraspecific_rank
  # Update notes with specific status info
  new_comment <-  paste0("Previous name was ", tmp$wcvp_status, " - Name changed in WCVP")
  
  # Update notes without overwriting
  tmp$wcvpnotes <- ifelse(is.na(tmp$wcvpnotes) | tmp$wcvpnotes == "", 
                          new_comment, 
                          paste(tmp$wcvpnotes, new_comment, sep = " | "))
  
  # Re-assign back to main processlist
  processlist[inc, ] <- tmp
}

```

## Case when the Family changed

```{r familychange}

# Identifying species where the name matches but the family is different
familychanged <- processlist %>% 
  filter(orig_name == Accepted_name & 
         wcvp_family != Accepted_family &  
         wcvp_status == "Accepted") %>%
  arrange(match_similarity)

print(paste0("Species with changes in family: ", nrow(familychanged)))

if(nrow(familychanged) > 0){
  datatable(
    familychanged %>% select(orig_family, Accepted_family, orig_name, Accepted_name, wcvp_status, match_similarity), 
    caption = "Species with changes in family",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```


```{r familyfix}
# Define the logical index (inc) using your NEW column names
inc <- with(processlist, (
    !is.na(orig_name) & 
    !is.na(Accepted_name) &  
    orig_name == Accepted_name &   
    wcvp_status == "Accepted" & 
    orig_name %in% familychanged$orig_name
))

# Safety check: are there any matches?
if (any(inc, na.rm = TRUE)) {
  
  # Create the temporary subset
  tmp <- processlist[inc, ]
  
  # Perform updates on the subset
  tmp$origchanged  <- TRUE
  # Update family only if Accepted_family is not NA
  tmp$wcvp_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$wcvp_family)

  new_comment <- "Family changed in WCVP"
  
  # Update notes without overwriting
  tmp$wcvpnotes <- ifelse(is.na(tmp$wcvpnotes) | tmp$wcvpnotes == "", 
                          new_comment, 
                          paste(tmp$wcvpnotes, new_comment, sep = " | "))
  
  # Re-assign back to processlist
  processlist[inc, ] <- tmp
}

# --- Sanity check ---
# Check by wcvp_genus 
genus_many_families <- processlist %>%
  group_by(wcvp_genus) %>%
  summarise(n_families = n_distinct(wcvp_family), .groups = "drop") %>%
  filter(n_families > 1)

if(nrow(genus_many_families) > 0){
  knitr::kable(genus_many_families, caption="Sanity check: Genus with more than one family")
}

# This is because of NA status, i will leave it as it is because they are unidentified species. 

```



## Cases in which original species name now have the same name under wcvp:
```{r twonames}

# We now assume the wcvp_names have been revised and they are now the current accepted name.
# in some cases the original name was left because the wcvp match was not good


# Now two species can now have the same wcvp_name name. 
# It could be because as synonyms got its name corrected and the accepted species was already in the dataset
# Or two species are now considered the same and the accepted name was not in the dataset

# Identify cases where different original names now share the same wcvp_name
acceptednamesdup <- processlist %>% 
  filter(!is.na(wcvp_name)) %>%
  group_by(wcvp_name) %>% 
  filter(n() > 1) %>% 
  ungroup() %>%
  arrange(wcvp_name) %>%
  mutate(row_id = row_number())

if(nrow(acceptednamesdup) > 0){
  datatable(
    acceptednamesdup %>% select(row_id, wcvp_name, orig_name, Name_matched, wcvp_status, origchanged ), 
    caption = "Consolidation: Multiple original entries now share one Accepted Name.",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```

Do nothing because they have distinct codes

```{r twonamesfix}

name_accepted_changed_dup <- acceptednamesdup %>% filter(
  wcvp_status != "Accepted"
) %>% select(orig_name)

inc <- with(processlist, (
    orig_name %in% name_accepted_changed_dup$orig_name
))

# Safety check: are there any matches?
if (any(inc, na.rm = TRUE)) {
  
  # Create the temporary subset
  tmp <- processlist[inc, ]
  
  # Update notes without overwriting
  tmp$wcvpnotes <- "WCVP name is the same as another species in list"
  tmp$wcvpsynonyms <- tmp$wcvp_name
  # Perform updates on the subset
  tmp$origchanged  <- TRUE
  
  # Go back to original name
  tmp$wcvp_family  <- tmp$orig_family
  tmp$wcvp_name <- tmp$orig_name
  tmp$wcvp_author <- tmp$orig_author
  tmp$wcvp_genus   <- tmp$orig_genus
  tmp$wcvp_species <- tmp$orig_species
  tmp$wcvp_infraspecies <- tmp$orig_infraspecies
  tmp$wcvp_infrasp_rank <- tmp$orig_infrasp_rank
  
  # Re-assign back to processlist
  processlist[inc, ] <- tmp
}

processlist_clean <- processlist


```


## Summary of modifications
```{r summarymod}
# Filter for species that were modified in the main list
species_modified <- processlist_clean %>% 
  filter(origchanged == TRUE) %>% 
  arrange(wcvpnotes, orig_name)

# Calculate Percentage of change
change_perc <- (nrow(species_modified) / nrow(processlist_clean)) * 100
print(paste0("Total species modified/consolidated: ", nrow(species_modified)))
print(paste0("Percentage of dataset modified: ", round(change_perc, 2), "%"))

# Save modifications in a separate file (using the path variables from setup)
write_xlsx(species_modified, out_wcvp_changes_list)

# Summary table of change types
knitr::kable(species_modified %>% 
               group_by(wcvpnotes) %>% 
               summarise(n_species = n(), .groups = "drop"), 
             caption = "Summary of changes by category")

# Detailed interactive table of all changes
datatable(
  species_modified %>% 
    select(orig_name, wcvp_name, orig_family, wcvp_family, wcvp_status, wcvpnotes),
  caption = "Species modified after matching with WCVP",
  options = list(scrollX = TRUE, pageLength = 20),
  rownames = FALSE
)
```

## Sanity check:  species were the name didint change and check duplicated species.

```{r}
# 1. Check for species where our final name still differs from the WCVP Accepted Name
species_no_wcvp <- processlist_clean %>% 
  filter(is.na(wcvp_name) | is.na(Accepted_name) | wcvp_name != Accepted_name)

print(paste0("Species where final name differs from WCVP Accepted Name: ", nrow(species_no_wcvp)))

if(nrow(species_no_wcvp) > 0){
  datatable(
    species_no_wcvp %>% 
      select(orig_name, wcvp_name, Name_matched, Accepted_name, wcvp_family, wcvp_status, wcvpnotes), 
    caption = "Species requiring manual review (Name mismatch)",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

# 2. Final check for duplicates: This should ideally return 0 rows
final_duplicates <- processlist_clean %>% 
  filter(!is.na(wcvp_name)) %>%
  group_by(wcvp_name) %>% 
  filter(n() > 1) %>% 
  ungroup() %>%
  mutate(mismatch = (orig_name != Name_matched)) %>% 
  arrange(wcvp_name, mismatch, match_similarity) %>%
  select(wcvp_name, orig_name, Name_matched, wcvp_status, mismatch, match_similarity)

if(nrow(final_duplicates) > 0){
  knitr::kable(final_duplicates, caption = "WARNING: Remaining Duplicates Found")
} else {
  print("Sanity Check Passed: No duplicates remaining in the final list.")
}
```

### Species with missing information in some column

```{r missinginfo}

# Flags species where the genus column doesn't match the first word of the species name,
# or where essential taxonomic fields are NA.
missing_info <- processlist_clean %>% filter(
  (!is.na(wcvp_name) & stringr::word(wcvp_name, 1) != wcvp_genus) |
  is.na(wcvp_genus) | is.na(wcvp_family) | is.na(wcvp_author) | is.na(wcvp_species)
)   

if(nrow(missing_info) > 0) {
  datatable(
    missing_info %>% select(
      wcvp_name, orig_name, wcvp_family, orig_family, 
      wcvp_genus, wcvp_species, wcvp_author, orig_author, 
      Accepted_name_author, origchanged, wcvp_status, wcvpnotes
    ),
    caption = "Species with missing or inconsistent taxonomic information",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```

Adding family and author names:

```{r}

processlist_clean <- processlist_clean %>%
  mutate(
    wcvp_family = ifelse(!wcvp_name %in% species_no_wcvp$wcvp_name, Accepted_family, wcvp_family),
    wcvp_author = ifelse(!wcvp_name %in% species_no_wcvp$wcvp_name, Accepted_name_author, wcvp_author),
)

```


## Save output with WCVP names of all PanamaBiota species.
```{r saveoutput}
# Remove some columns
# Standardize lifeform column name and remove technical matching columns
outtaxa <- processlist_clean %>%
  rename(
    wcvp_lifeform_description = lifeform_description
  ) %>%
  select(
    -Name_matched, -wcvp_authors, -Name_matched_rank, -Accepted_name, 
    -wcvp_status, -Accepted_family, -Accepted_name_rank, -Accepted_name_author, 
    -Accepted_name_status, -Accepted_name_genus, -Accepted_name_species, 
    -Accepted_name_infraspecific_rank, -Accepted_name_infraspecies,
    -match_similarity, -match_edit_distance
  )

# Save using the path defined in your setup chunk
write_xlsx(outtaxa, out_wcvp_list)
```

Saved `r nrow(outtaxa)` species in Panama Biota lists with their names verified with WCVP. 