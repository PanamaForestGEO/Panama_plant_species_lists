---
title: "Matching Garwood 2009 species names to WCVP"
author: "Paula Uzcategui"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Match WCVP names with species name

Next we do:

Input: list of species from Garwood 2009

- Match wcvp names
- Trying to be careful with species mismatches. Changing a species name when the match is not perfect needs manual verification.
- After the update two species can have the same WCVP name. Duplicates are removed but their original name is kept in a synonyms column.


Output: 

- _WCVP file with the original species list columns and the columns from wcvp
- _WCVP_CHANGES a file containing only the species where the WCVP name differed from the original. 


Notes on things to do:
- Change to using "Garwood_2009_Appendix1HM2.xlsx" instead of .csv file.  

```{r setup2, echo=TRUE,message=FALSE, warning=FALSE, results="hide"}

# installing wcvp
#install.packages("remotes")
#library(remotes)
#remotes::install_github("matildabrown/rWCVP")

rm(list=ls())

library("readxl")
library("writexl")
library("dplyr")
library("tidyr")
library("stringr")
suppressPackageStartupMessages({
  library(rWCVP)
  library(rWCVPdata)
})
library(TNRS)
library(DT)
library(stringi)
library(stringdist)

citation("rWCVPdata") # according to this, this is using version 13.


```


```{r globalvars}
# Load WCVP backbone
wcvp_names <- rWCVPdata::wcvp_names 

# INPUT PATHS
original_list_path <- "splists_raw/Garwood/Garwood_2009_Appendix1.csv" 

# Extract file name without extension 
original_list_name <- tools::file_path_sans_ext(basename(original_list_path))

# Path for intermediate matching results (to skip heavy processing if already done)
matches_mid_path <- paste0("splists_mid/", original_list_name, "_mid_match.rds")
matches_mid_path2 <- paste0("splists_mid/", original_list_name, "_mid_match2.rds")

# OUTPUT PATHS 
out_wcvp_list <- paste0("splists_out/", original_list_name, "_WCVP_", Sys.Date(), ".xlsx")
out_wcvp_changes_list <- paste0("splists_out/", original_list_name, "_WCVP_CHANGES_", Sys.Date(), ".xlsx")


redoWCVP= FALSE
```


## Prepare datasets

Modify this according to your dataset

```{r preparedata}

origlist <- read.csv(original_list_path)

# modify this depending on the original dataset. 
origlist <- origlist %>%
  rename(
    orig_family = Family.APG2,
    orig_genus = Genus,
    orig_species = Species,
    orig_author = Author,
    orig_infraspecies_rank = v.s,
    orig_infraspecies = Varsub
  ) %>% 
  mutate(orig_infraspecies_rank=ifelse(orig_infraspecies_rank=="ssp.","subsp.",orig_infraspecies_rank)) %>%
  mutate(orig_name = case_when(
        is.na(orig_species) | orig_species == "" ~ orig_genus,
        !is.na(orig_infraspecies) & orig_infraspecies != "" ~ paste(orig_genus, orig_species, orig_infraspecies_rank, orig_infraspecies),
        TRUE ~ paste(orig_genus, orig_species))
        ) %>%
  mutate(orig_name = str_squish(orig_name)) %>% # remove extra spaces inside name
  arrange(orig_name)

# add columns for the simple species name (not including "sp." or such), and simple binomial
origlist <- origlist %>%
  mutate(orig_justspecies = ifelse(substr(orig_species,1,3)=="sp.","",orig_species),
         orig_binomial=str_squish(paste0(orig_genus," ", 
                              ifelse(!is.na(orig_justspecies),orig_justspecies,""))))

# find duplicates
dups <- origlist %>% group_by(orig_name) %>% filter(n() > 1) %>% select(orig_name, Prefix, SYNONYMS, chg2, chg)

if(nrow(dups) > 0){
  knitr::kable(dups, caption="Duplicated names in original")
}


```

Do some manual fixes to records that will otherwise not run through the rest of the workflow properly.  Specifically for Ficus aff. trigonata, and Trema micranthum 

```{r manualfixes}
# make a manual fix to this single case of duplicates, so that they are no longer duplicates
# and to better reflect what the text says about them
inc <- origlist$orig_name=="Ficus trigonata" & origlist$Prefix=="sp. aff."
origlist$orig_name[inc] <- "Ficus aff. trigonata"
origlist$orig_binomial[inc] <- "Ficus"

inc2 <- origlist$orig_name=="Trema micrantha" 
origlist$orig_binomial[inc2] <- "Trema micranthum"


```

Working with `r nrow(origlist)` species. 

 
### Match WCVP names

```{r mergewcvp}
# Helper function to merge and format accepted names from WCVP backbone
matchaccepted_names <- function(matcheswcvp, wcvp_backbone){
  matcheswcvp %>% 
    left_join(wcvp_backbone %>% 
                select(plant_name_id, genus, species, taxon_rank, family, 
                       primary_author, infraspecific_rank, infraspecies, 
                       lifeform_description, taxon_status),
              by = c("wcvp_accepted_id" = "plant_name_id")) %>% 
    mutate(
      Accepted_name = case_when(
        is.na(species) | species == "" ~ genus,
        !is.na(infraspecies) & infraspecies != "" ~ paste(genus, species, infraspecific_rank, infraspecies),
        TRUE ~ paste(genus, species))
    ) %>%
    rename(
      Accepted_family = family,
      Accepted_name_rank = taxon_rank,
      Accepted_name_author = primary_author,
      Accepted_name_status = taxon_status,
      Accepted_name_genus = genus, 
      Accepted_name_species = species, 
      Accepted_name_infraspecific_rank = infraspecific_rank, 
      Accepted_name_infraspecies = infraspecies
    )
}

# --- 1. Run or Load Match ---
if(file.exists(matches_mid_path) & !redoWCVP){
  matchresult <- readRDS(matches_mid_path)
} else {
  # Run the matching process
  matchresult <- wcvp_match_names(origlist, wcvp_names, name_col = "orig_name")

  # Save as RDS for speed
  saveRDS(matchresult, matches_mid_path)
}

# do the same for the orig_binomial in cases where this is not equal to orig_name
if(file.exists(matches_mid_path2) & !redoWCVP){
  matchresult2 <- readRDS(matches_mid_path2)
} else {
  matchresult2 <- wcvp_match_names(subset(origlist,orig_name!=orig_binomial), wcvp_names, 
                                   name_col = "orig_binomial")

  # Save as RDS for speed
  saveRDS(matchresult2, matches_mid_path2)
}

# --- 2. Sanity Checks & Duplicate Resolution ---
# Ensure all species are accounted for
stopifnot(all(origlist$orig_name %in% matchresult$orig_name))

# Identify names that mapped to multiple 'Accepted' records
manyaccepted <- matchresult %>%
  group_by(orig_name) %>%
  filter(sum(wcvp_status == "Accepted", na.rm = TRUE) > 1) %>%
  ungroup()

# If duplicates exist, force use of the original ID to avoid grouping explosion
if (nrow(manyaccepted) > 0) {
  matchresult <- matchresult %>%
    mutate(wcvp_accepted_id = ifelse(orig_name %in% manyaccepted$orig_name, wcvp_id, wcvp_accepted_id))
}

# --- 3. Clean Match Results (1 row per species) ---
matchresult_clean <- matchresult %>%
  mutate(
    status_priority = case_when(
      wcvp_status == "Accepted"     ~ 1,
      wcvp_status == "Synonym"      ~ 2,
      wcvp_status == "Illegitimate" ~ 3,
      wcvp_status == "Unplaced"     ~ 4,
      TRUE                          ~ 5
    )
  ) %>%
  group_by(orig_name) %>%
  slice_min(status_priority, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  matchaccepted_names(wcvp_names)

matchresult2_clean <- matchresult2 %>%
  mutate(
    status_priority = case_when(
      wcvp_status == "Accepted"     ~ 1,
      wcvp_status == "Synonym"      ~ 2,
      wcvp_status == "Illegitimate" ~ 3,
      wcvp_status == "Unplaced"     ~ 4,
      TRUE                          ~ 5
    )
  ) %>%
  group_by(orig_name) %>%
  slice_min(status_priority, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  matchaccepted_names(wcvp_names)

```

### Fix mismatches

```{r spot_mismatch}

mismatches <- matchresult_clean %>% 
  filter(orig_name != wcvp_name | is.na(wcvp_name) | is.na(Accepted_name)) %>%
  left_join(matchresult2_clean %>% select(-orig_binomial) %>% rename_with(~paste0(., "_binomial"), -orig_name),
            by = "orig_name") %>%
  mutate(
    # Extract wcvp genus, species, infraspecies rank and infraspecies
    wcvp_genus = word(wcvp_name, 1),
    wcvp_species = word(wcvp_name, 2),
    wcvp_infraspecies_rank = word(wcvp_name, 3),
    wcvp_infraspecies = word(wcvp_name, 4),
    
    # Extract binomial genus, species, infraspecies rank and infraspecies
    wcvp_genus_binomial = word(wcvp_name_binomial, 1),
    wcvp_species_binomial = word(wcvp_name_binomial, 2),
    wcvp_infraspecies_rank_binomial = word(wcvp_name_binomial, 3),
    wcvp_infraspecies_binomial = word(wcvp_name_binomial, 4),
    
   # Add booleans for mismatches
    genus_mismatch = !is.na(orig_genus) & 
                      (orig_genus != wcvp_genus | is.na(wcvp_genus)),
    species_mismatch = !is.na(orig_species) & 
                        (orig_species != wcvp_species | is.na(wcvp_species)),
    infraspecies_rank_mismatch = !is.na(orig_infraspecies_rank) & 
                                  (orig_infraspecies_rank != wcvp_infraspecies_rank | 
                                   is.na(wcvp_infraspecies_rank)),
    infraspecies_mismatch = !is.na(orig_infraspecies) & 
                             (orig_infraspecies != wcvp_infraspecies | 
                              is.na(wcvp_infraspecies))
  )


printmismatches <- mismatches %>% 
  select(
    orig_name, wcvp_name, Accepted_name, match_similarity, 
    orig_binomial, wcvp_name_binomial, Accepted_name_binomial, match_similarity_binomial,
    genus_mismatch, species_mismatch, infraspecies_rank_mismatch, infraspecies_mismatch
  ) %>% 
  arrange(match_similarity, match_similarity_binomial)

datatable(printmismatches,options = list(scrollX = TRUE, pageLength = 10))


colsprint = c("orig_name", "wcvp_name","Accepted_name" ,"orig_binomial", "wcvp_name_binomial", "Accepted_name_binomial")

# 3.5  Compare matches in cases where orig_name and orig_binomial differ

matchresult12_clean <- merge(matchresult2_clean,matchresult_clean,by="orig_name",all.x=T)

matchresult12_clean <- matchresult12_clean %>%
  mutate(orig_name = str_replace_all(orig_name, "ssp\\.", "subsp."))
temp <- matchresult12_clean %>% 
  rename(Accepted_name_matchbinomial=Accepted_name.x,
         Accepted_name_matchfull = Accepted_name.y,
         Matched_name_matchbinomial=wcvp_name.x,
         Matched_name_matchfull=wcvp_name.y) %>%
  mutate(match_2words = (word(Matched_name_matchfull,1,2)==word(orig_name,1,2))) %>%
  select(orig_name,Matched_name_matchfull,
         match_2words,match_similarity.y,Accepted_name_matchfull,
                                       orig_binomial.x,Matched_name_matchbinomial,
                                       match_similarity.x,Accepted_name_matchbinomial) %>%
  arrange(match_2words)

temp2a <- subset(temp, orig_name!=Matched_name_matchfull & match_similarity.x==1)
temp2b <- subset(temp, orig_name!=Matched_name_matchfull & match_similarity.x!=1)
# applying the rules: 

# based on spot-checking, there are several cases:
# (5) There is an imperfect match (spelling change) for the binomial match, and a similarly imperfect match (spelling change) in the full match.  The full match is preferred. (3 cases)  
# (1) There is a perfect match for the binomial, and the matched full WCVP name has a different genus or species.  In all these cases, the match on the full name is bad, and the match on the binomial should be preferred. (9 cases)
# (remaining are 16 cases in all)
# (2) There is a perfect match for the binomial, and The full matched WCVP name has the same binomial, and the same infraspecific name, but a different infraspecific rank.  In these cases the full match is preferred.
# (3) There is a perfect match for the binomial, and The full matched WCVP name has the same binomial and infraspecific rank, and there is a small spelling change in the infraspecific name.  In these cases the full match is preferred.
# (4) There is a perfect match for the binomial, and The full matched WCVP name has the same binomial and infraspecific rank, and a completely differe infraspecific name.  In these cases the binomial match is preferred. 

# potential workflow - evaluate match separately for genus, species, infrasp rank, infraspecies in the full match, and for genus and species in the binomial match.  
# quantify match with stringdist function stringsim(name1, name2,method="jw")
# and then apply the rules above using that


# Simple alternative is that in all cases where there is not a perfect match on the full name, use the binomial match instead.  This will miss a few cases where the full match is better, but avoid a lot of problems. 

# for fixes the original full name is preferred unless said otherwise
mismatches$preferred = "full"
```

```{r printmisses}
# both binomial and full mismatched
misscase1 <- mismatches %>% filter( orig_name != wcvp_name   &
                        (orig_binomial != wcvp_name_binomial | is.na(wcvp_name_binomial)) )

datatable( misscase1 %>% select(all_of(colsprint)),
           caption="both binomial and full name mismatched",
options = list(scrollX = TRUE, pageLength = 10))

```
The mismatch is a small typo. Leave the accepted name as it is.  EXCEPT for Trema micrantha.

In that case leave the original name.
```{r fixingcase2}

inc <- with(mismatches, orig_name =="Trema micrantha")
if (any(inc, na.rm = TRUE)) {
  tmp <- mismatches[inc, ]
  tmp$preferred = "original"
  mismatches[inc, ] <- tmp
}

```


```{r case3}
# full name matched except infraspecies rank
misscase3 <- mismatches %>% filter( infraspecies_rank_mismatch & !genus_mismatch & !species_mismatch & !infraspecies_mismatch) 
  
datatable( misscase3 %>% select(all_of(colsprint)),
           caption="full name matched except infraspecies rank",options = list(scrollX = TRUE, pageLength = 10))

```

The mismatch is a difference only in infraspecific rank. Use the WCVP accepted name for the full match. 


```{r findingcase2}
# full name mismatched, binomial didin't. And genus and species did not mismatch
# this is because the infraspecies is messing the fuzzy matching
misscase2 <- mismatches %>% filter( orig_name != wcvp_name &
                       orig_binomial == wcvp_name_binomial &
                      (genus_mismatch | species_mismatch)
                         ) 
datatable( misscase2 %>% select(all_of(colsprint)),
           caption="Mismatch for full name involving a mismatch on genus or species, and at the same time perfect match when just on binomial.",
           options = list(scrollX = TRUE, pageLength = 10)
           )


```
In this cases the match to binomial is better, so use that.  (Note also the infraspecies is the same as the species in all these cases except the one without a species name at all.) 
```{r fixingcase3}

inc <- with(mismatches, orig_name %in% misscase2$orig_name)
if (any(inc, na.rm = TRUE)) {
  tmp <- mismatches[inc, ]
  tmp$preferred = "binomial"
  mismatches[inc, ] <- tmp
}

```


```{r case4}
# genus, species and rank matched but infraspecies didint 
misscase4 <- mismatches %>% filter( !genus_mismatch & !species_mismatch & infraspecies_mismatch & !infraspecies_rank_mismatch)

datatable( misscase4 %>% select(all_of(colsprint)), caption="genus, species and infraspecific rank matched but infraspecies name did not ",options = list(scrollX = TRUE, pageLength = 10))

# no 5 case, i dont think string comparing is reliable

```

In all of this cases the subspecies did not match in wcvp. Thus using the simple binomial match instead (dropping the infraspecies).

```{r fixingcase4}
inc <- with(mismatches, orig_name %in% misscase4$orig_name)
if (any(inc, na.rm = TRUE)) {
  tmp <- mismatches[inc, ]
  tmp$preferred = "binomial"
  mismatches[inc, ] <- tmp
}
```


```{r case5}
# species not considered in the previous cases:
missrest <- mismatches %>% 
  filter(!orig_name %in% c(misscase1$orig_name, misscase2$orig_name, misscase3$orig_name, misscase4$orig_name))

datatable( missrest %>% select(all_of(colsprint)), caption="Species not considered in previous cases",options = list(scrollX = TRUE, pageLength = 10))

```
For all of these, there is no WCVP match to the full name, but in most cases there is a match to the binomial name.  Thus use the binomial name.  And in the cases where there is no match, it is because of a lack of taxonomic resolution in the original ID (just to family).  


```{r fixingcase5}

inc <- with(mismatches, orig_name %in% missrest$orig_name)
if (any(inc, na.rm = TRUE)) {
  tmp <- mismatches[inc, ]
  tmp$preferred = "binomial"
  mismatches[inc, ] <- tmp
}


```


```{r fixingmismatches}

# summary of mismatches
mismatches %>% group_by(preferred) %>% summarise(n())

mismatches <- mismatches %>% mutate(
  across(
    c(wcvp_name, wcvp_authors, wcvp_rank, wcvp_status, wcvp_homotypic, 
      wcvp_ipni_id, wcvp_accepted_id, Accepted_name, Accepted_name_genus, 
      Accepted_name_species, Accepted_name_rank, Accepted_family, 
      Accepted_name_author, Accepted_name_infraspecific_rank, 
      Accepted_name_infraspecies, match_similarity),
    ~case_when(
      preferred == "binomial" ~ get(paste0(cur_column(), "_binomial")),
      preferred == "original" ~ NA,
      TRUE ~ .x
    )
  )
)
```


Now all the mismatches should make more sense
```{r printnowmatches}

printmismatches <- mismatches %>% 
  select(
    orig_name, wcvp_name, Accepted_name) %>% 
  arrange(match_similarity, match_similarity_binomial)

datatable(printmismatches,options = list(scrollX = TRUE, pageLength = 10))

```



```{r matcheshandling}

# --- 4. Handle  matches ---

# correct the mismatches

inc <- with(matchresult_clean, orig_name %in% mismatches$orig_name)
if (any(inc, na.rm = TRUE)) {
  corrections <- mismatches %>%
    select(orig_name,wcvp_name, wcvp_authors, wcvp_rank, wcvp_status, 
           wcvp_homotypic, wcvp_ipni_id, wcvp_accepted_id, Accepted_name, 
           Accepted_name_genus, Accepted_name_species, Accepted_name_rank, 
           Accepted_family, Accepted_name_author, Accepted_name_infraspecific_rank, 
           Accepted_name_infraspecies, match_similarity)
  
  matchresult_clean <- rows_update(matchresult_clean, corrections, 
                                   by = "orig_name")
}


# --- 5. Final Join and Rename ---
# This merges the WCVP data back into your processed original list
processlist <- origlist %>%
  left_join(matchresult_clean %>% 
              select(orig_name, wcvp_name, wcvp_authors, wcvp_rank, wcvp_status, 
                     Accepted_name, Accepted_family, Accepted_name_rank, 
                     Accepted_name_author, Accepted_name_status, Accepted_name_genus,
                     Accepted_name_species, Accepted_name_infraspecific_rank, 
                     Accepted_name_infraspecies, lifeform_description, 
                     match_similarity, match_edit_distance),
            by = "orig_name") %>%
  rename(
    wcvp_matched_name = wcvp_name,
    wcvp_matched_authors = wcvp_authors,
    wcvp_matched_rank = wcvp_rank,
    wcvp_matched_status=wcvp_status,
    wcvp_accepted_name = Accepted_name,
  wcvp_accepted_family = Accepted_family,
  wcvp_accepted_author = Accepted_name_author,
  wcvp_lifeform_description = lifeform_description
  )

# Review Results
processlist %>% count(wcvp_status)

knitr::kable(subset(processlist,
             !wcvp_status %in% c("Accepted", "Synonym")) %>% 
        select(orig_family,orig_name,wcvp_status,Accepted_name),
      caption = "Species not listed as Accepted or Synonym in WCVP")
```

# Ready the output:


```{r readyoutput}
processlist <- processlist %>% mutate(
  origmatches = orig_name==wcvp_matched_name,
  current_name_notes = ""
)



# Clean columns with weird characters
processlist <- processlist %>%
  mutate(across(where(is.character), ~ stri_encode(., from = NULL, to = "UTF-8"))) 

# Optional: removes accents
#processlist <- processlist %>%
#    mutate(across(where(is.character), ~ stri_trans_general(., "latin-ascii"))) 
```


## Save output of all species.
```{r saveoutput}
# Remove some columns
# Standardize lifeform column name and remove technical matching columns
outtaxa <- processlist 
  select(
     -wcvp_authors, -Name_matched_rank, -Accepted_name, 
    -Accepted_family, -Accepted_name_rank, -Accepted_name_author, 
    -Accepted_name_status, -Accepted_name_genus, -Accepted_name_species, 
    -Accepted_name_infraspecific_rank, -Accepted_name_infraspecies,
    -match_similarity, -match_edit_distance
  )

# Save using the path defined in your setup chunk
write_xlsx(outtaxa, out_wcvp_list)
```

Saved `r nrow(outtaxa)` species with their names verified with WCVP. 

ADD HERE - output the taxa that have any differences between accepted name and orig_name as a separate file of changes.  

