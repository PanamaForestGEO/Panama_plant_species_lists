---
title: "Matching Garwood 2009 species names to WCVP"
author: "Paula Uzcategui"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Match WCVP names with species name

Next we do:

Input: list of species from Garwood 2009

- Match wcvp names
- Trying to be careful with species mismatches. Changing a species name when the match is not perfect needs manual verification.
- After the update two species can have the same WCVP name. Duplicates are removed but their original name is kept in a synonyms column.


Output: 

- _WCVP file with the original species list columns and the columns from wcvp
- _WCVP_CHANGES a file containing only the species where the WCVP name differed from the original. 
Notes on things to do:
- Change to using "Garwood_2009_Appendix1HM2.xlsx" instead of .csv file.  

```{r setup2, echo=TRUE,message=FALSE, warning=FALSE, results="hide"}

# installing wcvp
#install.packages("remotes")
#library(remotes)
#remotes::install_github("matildabrown/rWCVP")

rm(list=ls())

library("readxl")
library("writexl")
library("dplyr")
library("tidyr")
library("stringr")
suppressPackageStartupMessages({
  library(rWCVP)
  library(rWCVPdata)
})
library(TNRS)
library(DT)
library(stringi)

citation("rWCVPdata") # according to this, this is using version 13.


```


```{r globalvars}
# Load WCVP backbone
wcvp_names <- rWCVPdata::wcvp_names 

# INPUT PATHS
original_list_path <- "splists_raw/Garwood/Garwood_2009_Appendix1.csv" 

# Extract file name without extension 
original_list_name <- tools::file_path_sans_ext(basename(original_list_path))

# Path for intermediate matching results (to skip heavy processing if already done)
matches_mid_path <- paste0("splists_mid/", original_list_name, "_mid_match.rds")
matches_mid_path2 <- paste0("splists_mid/", original_list_name, "_mid_match2.rds")

# OUTPUT PATHS 
out_wcvp_list <- paste0("splists_out/", original_list_name, "_WCVP_", Sys.Date(), ".xlsx")
out_wcvp_changes_list <- paste0("splists_out/", original_list_name, "_WCVP_CHANGES_", Sys.Date(), ".xlsx")


redoWCVP= TRUE
```


## Prepare datasets

Modify this according to your dataset

```{r preparedata}

origlist <- read.csv(original_list_path)

# modify this depending on the original dataset. 
origlist <- origlist %>%
  rename(
    orig_family = Family.APG2,
    orig_genus = Genus,
    orig_species = Species,
    orig_author = Author,
    orig_infrasp_rank = v.s,
    orig_infraspecies = Varsub
  ) %>% 
  mutate(orig_infrasp_rank=ifelse(orig_infrasp_rank=="ssp.","subsp.",orig_infrasp_rank)) %>%
  mutate(orig_name = case_when(
        is.na(orig_species) | orig_species == "" ~ orig_genus,
        !is.na(orig_infraspecies) & orig_infraspecies != "" ~ paste(orig_genus, orig_species, orig_infrasp_rank, orig_infraspecies),
        TRUE ~ paste(orig_genus, orig_species))
        ) %>%
  mutate(orig_name = str_squish(orig_name)) %>% # remove extra spaces inside name
  arrange(orig_name)

# add columns for the simple species name (not including "sp." or such), and simple binomial
origlist <- origlist %>%
  mutate(orig_justspecies = ifelse(substr(orig_species,1,3)=="sp.","",orig_species),
         orig_binomial=str_squish(paste0(orig_genus," ", 
                              ifelse(!is.na(orig_justspecies),orig_justspecies,""))))

# find duplicates
dups <- origlist %>% group_by(orig_name) %>% filter(n() > 1) %>% select(orig_name, Prefix, SYNONYMS, chg2, chg)

if(nrow(dups) > 0){
  knitr::kable(dups, caption="Duplicated names in original")
}

# make a manual fix to this single case of duplicates, so that they are no longer duplicates
# and to better reflect what the text says about them
inc <- origlist$orig_name=="Ficus trigonata" & origlist$Prefix=="sp. aff."
origlist$orig_name[inc] <- "Ficus aff. trigonata"
origlist$orig_binomial[inc] <- "Ficus"

# leaving duplicates for now given all the other information in the rows.
```
Working with `r nrow(origlist)` species. 

 
### Match WCVP names

```{r mergewcvp}
# Helper function to merge and format accepted names from WCVP backbone
matchaccepted_names <- function(matcheswcvp, wcvp_backbone){
  matcheswcvp %>% 
    left_join(wcvp_backbone %>% 
                select(plant_name_id, genus, species, taxon_rank, family, 
                       primary_author, infraspecific_rank, infraspecies, 
                       lifeform_description, taxon_status),
              by = c("wcvp_accepted_id" = "plant_name_id")) %>% 
    mutate(
      Accepted_name = case_when(
        is.na(species) | species == "" ~ genus,
        !is.na(infraspecies) & infraspecies != "" ~ paste(genus, species, infraspecific_rank, infraspecies),
        TRUE ~ paste(genus, species))
    ) %>%
    rename(
      Accepted_family = family,
      Accepted_name_rank = taxon_rank,
      Accepted_name_author = primary_author,
      Accepted_name_status = taxon_status,
      Accepted_name_genus = genus, 
      Accepted_name_species = species, 
      Accepted_name_infraspecific_rank = infraspecific_rank, 
      Accepted_name_infraspecies = infraspecies
    )
}

# --- 1. Run or Load Match ---
if(file.exists(matches_mid_path)){
  matchresult <- readRDS(matches_mid_path)
} else {
  # Run the matching process
  matchresult <- wcvp_match_names(origlist, wcvp_names, name_col = "orig_name")

  # Save as RDS for speed
  saveRDS(matchresult, matches_mid_path)
}

# do the same for the orig_binomial in cases where this is not equal to orig_name
if(file.exists(matches_mid_path2)){
  matchresult2 <- readRDS(matches_mid_path2)
} else {
  matchresult2 <- wcvp_match_names(subset(origlist,orig_name!=orig_binomial), wcvp_names, 
                                   name_col = "orig_binomial")

  # Save as RDS for speed
  saveRDS(matchresult2, matches_mid_path2)
}

# --- 2. Sanity Checks & Duplicate Resolution ---
# Ensure all species are accounted for
stopifnot(all(origlist$orig_name %in% matchresult$orig_name))

# Identify names that mapped to multiple 'Accepted' records
manyaccepted <- matchresult %>%
  group_by(orig_name) %>%
  filter(sum(wcvp_status == "Accepted", na.rm = TRUE) > 1) %>%
  ungroup()

# If duplicates exist, force use of the original ID to avoid grouping explosion
if (nrow(manyaccepted) > 0) {
  matchresult <- matchresult %>%
    mutate(wcvp_accepted_id = ifelse(orig_name %in% manyaccepted$orig_name, wcvp_id, wcvp_accepted_id))
}

# --- 3. Clean Match Results (1 row per species) ---
matchresult_clean <- matchresult %>%
  mutate(
    status_priority = case_when(
      wcvp_status == "Accepted"     ~ 1,
      wcvp_status == "Synonym"      ~ 2,
      wcvp_status == "Illegitimate" ~ 3,
      wcvp_status == "Unplaced"     ~ 4,
      TRUE                          ~ 5
    )
  ) %>%
  group_by(orig_name) %>%
  slice_min(status_priority, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  matchaccepted_names(wcvp_names)

matchresult2_clean <- matchresult2 %>%
  mutate(
    status_priority = case_when(
      wcvp_status == "Accepted"     ~ 1,
      wcvp_status == "Synonym"      ~ 2,
      wcvp_status == "Illegitimate" ~ 3,
      wcvp_status == "Unplaced"     ~ 4,
      TRUE                          ~ 5
    )
  ) %>%
  group_by(orig_name) %>%
  slice_min(status_priority, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  matchaccepted_names(wcvp_names)

# 3.5  Compare matches in cases where orig_name and orig_binomial differ

matchresult12_clean <- merge(matchresult2_clean,matchresult_clean,by="orig_name",all.x=T)

matchresult12_clean <- matchresult12_clean %>%
  mutate(orig_name = str_replace_all(orig_name, "ssp\\.", "subsp."))
temp <- matchresult12_clean %>% 
  rename(Accepted_name_matchbinomial=Accepted_name.x,
         Accepted_name_matchfull = Accepted_name.y,
         Matched_name_matchbinomial=wcvp_name.x,
         Matched_name_matchfull=wcvp_name.y) %>%
  mutate(match_2words = (word(Matched_name_matchfull,1,2)==word(orig_name,1,2))) %>%
  select(orig_name,Matched_name_matchfull,
         match_2words,match_similarity.y,Accepted_name_matchfull,
                                       orig_binomial.x,Matched_name_matchbinomial,
                                       match_similarity.x,Accepted_name_matchbinomial) %>%
  arrange(match_2words)

temp2a <- subset(temp, orig_name!=Matched_name_matchfull & match_similarity.x==1)
temp2b <- subset(temp, orig_name!=Matched_name_matchfull & match_similarity.x!=1)

# based on spot-checking, there are several cases:
# (5) There is an imperfect match (spelling change) for the binomial match, and a similarly imperfect match (spelling change) in the full match.  The full match is preferred. (3 cases)  
# (1) There is a perfect match for the binomial, and the matched full WCVP name has a different genus or species.  In all these cases, the match on the full name is bad, and the match on the binomial should be preferred. (9 cases)
# (remaining are 16 cases in all)
# (2) There is a perfect match for the binomial, and The full matched WCVP name has the same binomial, and the same infraspecific name, but a different infraspecific rank.  In these cases the full match is preferred.
# (3) There is a perfect match for the binomial, and The full matched WCVP name has the same binomial and infraspecific rank, and there is a small spelling change in the infraspecific name.  In these cases the full match is preferred.
# (4) There is a perfect match for the binomial, and The full matched WCVP name has the same binomial and infraspecific rank, and a completely differe infraspecific name.  In these cases the binomial match is preferred. 

# potential workflow - evaluate match separately for genus, species, infrasp rank, infraspecies in the full match, and for genus and species in the binomial match.  
# quantify match with stringdist function stringsim(name1, name2,method="jw")
# and then apply the rules above using that


# Simple alternative is that in all cases where there is not a perfect match on the full name, use the binomial match instead.  This will miss a few cases where the full match is better, but avoid a lot of problems.  


# --- 4. Handle missing matches ---
# If WCVP didn't find a match, using orig_name, substitute the match obtained using orig_binomial

cols_to_fill <- c(
  "match_type","multiple_matches","match_similarity","match_edit_distance",
  "wcvp_id","wcvp_name","wcvp_authors","wcvp_rank","wcvp_status","wcvp_homotypic",
  "wcvp_ipni_id","wcvp_accepted_id","status_priority","Accepted_name_genus",
  "Accepted_name_species","Accepted_name_rank","Accepted_family","Accepted_name_author",
  "Accepted_name_infraspecific_rank","Accepted_name_infraspecies","lifeform_description",
  "Accepted_name_status","Accepted_name"
)

# join in the "backup" values from matchresult2_clean
tmp <- matchresult_clean %>%
  left_join(
    matchresult2_clean %>% select(orig_name, all_of(cols_to_fill)),
    by = "orig_name",
    suffix = c("", "_2")
  )

# for rows with missing Accepted_name in matchresult_clean, replace from *_2 columns
for (col in cols_to_fill) {
  tmp[[col]] <- ifelse(
    is.na(tmp$Accepted_name),                   # condition based on original Accepted_name
    tmp[[paste0(col, "_2")]],                   # take from matchresult2_clean
    tmp[[col]]                                  # otherwise keep original
  )
}

# drop the joined *_2 columns
matchresult_clean <- tmp %>%
  select(-all_of(paste0(cols_to_fill, "_2")))

# after this, the only 2 remaining without accepted names were only identified at the family level. 

# --- 5. Final Join and Rename ---
# This merges the WCVP data back into your processed original list
processlist <- origlist %>%
  left_join(matchresult_clean %>% 
              select(orig_name, wcvp_name, wcvp_authors, wcvp_rank, wcvp_status, 
                     Accepted_name, Accepted_family, Accepted_name_rank, 
                     Accepted_name_author, Accepted_name_status, Accepted_name_genus,
                     Accepted_name_species, Accepted_name_infraspecific_rank, 
                     Accepted_name_infraspecies, lifeform_description, 
                     match_similarity, match_edit_distance),
            by = "orig_name") %>%
  rename(
    Name_matched = wcvp_name,
    Name_matched_rank = wcvp_rank
  )

# Review Results
processlist %>% count(wcvp_status)

kable(subset(processlist,
             !wcvp_status %in% c("Accepted", "Synonym")) %>% 
        select(orig_family,orig_name,wcvp_status,Accepted_name),
      caption = "Species not listed as Accepted or Synonym in WCVP")
```

# Fix synonyms and errors:

```{r checkerrors, echo=TRUE, results="hide"}

# For now lets assume the original name is the correct current name
processlist <- processlist %>% mutate(
  wcvp_name = Accepted_name,
  wcvp_family = Accepted_family,
  wcvp_author = Accepted_name_author,
  current_name = orig_name, # leave the original as current and check wcvp
  current_family  = str_to_sentence(orig_family),
  current_author = orig_author,
  origchanged = FALSE,
  current_name_notes = "",
  synonyms = "",
  orig_synonyms = ""
)


# Clean columns with weird characters
processlist <- processlist %>%
  mutate(across(where(is.character), ~ stri_encode(., from = NULL, to = "UTF-8"))) 

# Optional: removes accents
#processlist <- processlist %>%
#    mutate(across(where(is.character), ~ stri_trans_general(., "latin-ascii"))) 

```

### Case when no accepted name was found
```{r noaccepted}

species_na_wcvp <- processlist %>% filter(is.na(wcvp_status))

if(nrow(species_na_wcvp)>0){
  knitr::kable(species_na_wcvp %>% select( orig_name,  SYNONYMS))
}


```

### Case when name spelling differs

```{r spellingdfis}
# Identifying spelling differences
# We filter for cases where the name matched is different from original but is considered 'Accepted'
matchingerrors <- processlist %>%
  filter((orig_name != Name_matched) & 
           (orig_binomial != Name_matched) & 
           wcvp_status == "Accepted") %>%
  arrange(match_similarity)  %>%
  mutate(row_id = row_number())

# Display the potential spelling errors
if(nrow(matchingerrors) > 0){
    datatable(
    matchingerrors %>% select(row_id, orig_name, Name_matched, Accepted_name, match_similarity, SYNONYMS),
    caption = "Name is accepted but differs in spelling from original.",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```

Cydista aequinoctialis is Bignonia aequinoctialis. 

```{r fixcase}

processlist <- processlist %>% mutate(
  wcvp_name = ifelse(orig_name == "Cydista aequinoctialis var. aequinoctialis",  "Bignonia aequinoctialis", wcvp_name),
  wcvp_author =  ifelse(orig_name == "Cydista aequinoctialis var. aequinoctialis",  "L.", wcvp_author),
  origchanged =  ifelse(orig_name == "Cydista aequinoctialis var. aequinoctialis", TRUE, origchanged)
)

```


```{r spellfix}
# Manual selection of rows that are definitely spelling errors
# ADJUST THE Species based on your new matchingerrors table. 
# The idea is to leave out the species were the orig_name and the Naame matched clearly dont match

leave_orig_name1 <- c(
  "Trema micrantha",
  "Phyllanthus sp. A", 
  "Smilax spinosa var. spinosa", 
  "Cissus erosa ssp. erosa", 
  "Abarema barbouriana var. barbouriana",
  "Pouteria reticulata ssp. reticulata",
  "Cydista aequinoctialis var. aequinoctialis",
  "Maclura tinctoria ssp. tinctoria",
  "Entada polystachya var. polystachya"
)

# change name to the correct spelling of the species that are not in that list
changes_spelling1 <- matchingerrors %>%
  filter(!orig_name %in% leave_orig_name1) %>% 
  select(orig_name, Accepted_name)

# Create index for the main dataset
inc <- with(processlist, orig_name %in% changes_spelling1$orig_name)

# Review the subset to be modified
species_modified1 <- processlist[inc, ]

if(nrow(species_modified1) > 0){
  datatable(
    species_modified1 %>% select(orig_name, Name_matched, Accepted_name, match_similarity), 
    caption = "Spelling errors confirmed for correction.",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

# Apply the updates to the main processlist
if (any(inc, na.rm = TRUE)) {
  
  tmp <- processlist[inc, ]
  
  # Update logical flag and metadata
  tmp$origchanged  <- TRUE

  new_comment <- "Spelling changed in WCVP"
  
  # Update notes without overwriting
  tmp$current_name_notes <- ifelse(is.na(tmp$current_name_notes) | tmp$current_name_notes == "", 
                          new_comment, 
                          paste(tmp$current_name_notes, new_comment, sep = " | "))
  
  # Update taxonomy using the Accepted Name data from WCVP
  tmp$current_author  <- ifelse(!is.na(tmp$Accepted_name_author), tmp$Accepted_name_author, tmp$orig_author)
  tmp$current_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$current_family)
  tmp$current_name    <- tmp$Accepted_name
  
  # Keep original name in synonyms for traceability
  # Logic: If synonyms is empty, just add name. If not, append with separator.
  tmp$synonyms <- ifelse(is.na(tmp$synonyms) | tmp$synonyms == "", 
                             tmp$orig_name, 
                             paste(tmp$synonyms, tmp$orig_name, sep = "; "))
  
  # Re-assign the modified subset back to the original rows
  processlist[inc, ] <- tmp
}
```

## Cases in which two or more original species would have the same name under wcvp:
```{r twonames}

# Two species can now have the same accepted name. 
# It could be because as synonyms got its name corrected and the accepted species was already in the dataset
# Or two species are now considered the same and the accepted name was not in the dataset

# Identify cases where different original names now share the same wcvp_name
acceptednamesdup <- processlist %>% 
  filter(!is.na(Accepted_name)) %>%
  group_by(Accepted_name) %>% 
  filter(n() > 1) %>% 
  ungroup() %>%
  arrange(Accepted_name) %>%
  mutate(row_id = row_number())

if(nrow(acceptednamesdup) > 0){
  datatable(
    acceptednamesdup %>% select(row_id, Accepted_name, orig_name, Name_matched, wcvp_status, origchanged ), 
    caption = "Multiple original entries share one Accepted Name.",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```

```{r leaveoriginal}

# create a list of the duplicates to leave their original names

leave_orig_names_dups <- acceptednamesdup %>% filter(wcvp_status != "Accepted") %>% select(orig_name)

leave_orig_names_dups <- leave_orig_names_dups$orig_name
```


# Case when match is not perfect and species name has changed.
```{r noperfectchange}

# Filter for species where match isn't exact and status isn't Accepted
noacceptedwcvpname <- processlist %>% 
  filter(
    (is.na(wcvp_status) | wcvp_status != "Accepted") &
      !is.na(orig_name) &
      !is.na(Name_matched) &
      orig_name != Name_matched
  ) %>%
  arrange(wcvp_status, match_similarity) %>%
  mutate(row_id = row_number()) %>%
  select(row_id, orig_name, Name_matched, Accepted_name, wcvp_status, match_similarity) 


if(nrow(noacceptedwcvpname) > 0){
  datatable(
    noacceptedwcvpname, caption = "Species where the match is not exact and the name changes",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}
```


```{r noperfechchangefix}

# the subspecies doenst match well since i dont want to lose information i will leave it like the original name
leave_out_orig_name2 <- c(
  "Manihot esculenta ssp. esculenta", 
  "Begonia fischeri var. fischeri", 
  "Combretum laxum var. laxum", 
  "Streptochaeta spicata ssp. spicata", 
  "Syngonium podophyllum var. podophyllum", 
  "Aniseia martinicensis var. martinicensis",
  "Justicia pectoralis var. pectoralis", 
  "Pityrogramma calomelanos var. calomelanos",
  "Rhynchospora corymbosa var. corymbosa",
  "Oplismenus hirtellus ssp. hirtellus", 
  "Kyllinga odorata var. odorata", 
  "Simarouba amara var. amara",
  "Andropogon virginicus var. virginicus",
  "Panicum pilosum var. pilosum")


leave_out_names <- c(leave_orig_names_dups, leave_out_orig_name2)

# Select the row IDs that you have verified are correct spelling/name updates
# Note: Ensure these IDs match the table generated above
change_name2 <- noacceptedwcvpname %>%
  filter(!orig_name %in% leave_out_names) %>%
  select(orig_name, Accepted_name)

# Indexing the main processlist
inc <- with(processlist, orig_name %in% change_name2$orig_name)

# Display what will be modified
if (any(inc, na.rm = TRUE)) {
  species_modified2 <- processlist[inc,]
  
  datatable(
    species_modified2 %>% select(orig_name, Name_matched, Accepted_name, match_similarity), 
    caption = "Confirmed name changes (Keeping Accepted Name)",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
  
  tmp <- processlist[inc, ]
  
  # Update logical flag and metadata
  tmp$origchanged  <- TRUE

  new_comment <-  paste0("Imperfect match | Previous name was ", tmp$wcvp_status, " - Name changed in WCVP")
  
  # Update notes without overwriting
  tmp$current_name_notes <- ifelse(is.na(tmp$current_name_notes) | tmp$current_name_notes == "", 
                          new_comment, 
                          paste(tmp$current_name_notes, new_comment, sep = " | "))
  
  # Update taxonomy using the Accepted Name data from WCVP
  tmp$current_author  <- ifelse(!is.na(tmp$Accepted_name_author), tmp$Accepted_name_author, tmp$orig_author)
  tmp$current_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$current_family)
  tmp$current_name    <- tmp$Accepted_name
  
  # Keep original name in synonyms for traceability
  # Logic: If synonyms is empty, just add name. If not, append with separator.
  tmp$synonyms <- ifelse(is.na(tmp$synonyms) | tmp$synonyms == "", 
                             tmp$orig_name, 
                             paste(tmp$synonyms, tmp$orig_name, sep = "; "))
  
  # Re-assign the modified subset back to the original rows
  processlist[inc, ] <- tmp
}

```


## Change species name when the match was perfect and WCVP reported a name change:
```{r seechamngenames}


# Identify species where the match was perfect but status is NOT 'Accepted'
species_accepted_changed <- processlist %>% 
  filter(
    !is.na(orig_name) & 
    !is.na(Name_matched) & 
    orig_name == Name_matched & 
    wcvp_status != "Accepted"
  )

if(nrow(species_accepted_changed) > 0){
  datatable(
    species_accepted_changed %>% select(orig_name, Name_matched, Accepted_name, wcvp_status), 
    caption = "Species matched perfectly but status is not 'Accepted' (Synonyms/Illegitimate).",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}


```

```{r fixchangenames}
# Now the species names we would like to change:
# No missmatch between Name_matched and Current_name and The state is non accepted.

# Manual list of species to protect (do not update these even if WCVP suggests a change)
leave_orig_names <- c(
  "Swartzia simplex var. continentalis", 
  "Swartzia simplex var. grandiflora",
  leave_orig_name1, leave_out_orig_name2, leave_orig_names_dups)


# Define the logical index for the changes
inc <- with(processlist, (
  !is.na(orig_name) & 
  !is.na(Name_matched) & 
  orig_name == Name_matched & 
  wcvp_status != "Accepted" &
  !orig_name %in% leave_orig_names
))


if (any(inc, na.rm = TRUE)) {
  
  tmp <- processlist[inc, ]
  
  # Update logical flag and metadata
  tmp$origchanged  <- TRUE

  new_comment <-  paste0("Previous name was ", tmp$wcvp_status, " - Name changed in WCVP")
  

  # Update notes without overwriting
  tmp$current_name_notes <- ifelse(is.na(tmp$current_name_notes) | tmp$current_name_notes == "", 
                          new_comment, 
                          paste(tmp$current_name_notes, new_comment, sep = " | "))
  
  # Update taxonomy using the Accepted Name data from WCVP
  tmp$current_author  <- ifelse(!is.na(tmp$Accepted_name_author), tmp$Accepted_name_author, tmp$orig_author)
  tmp$current_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$current_family)
  tmp$current_name    <- tmp$Accepted_name
  
  # Keep original name in synonyms for traceability
  # Logic: If synonyms is empty, just add name. If not, append with separator.
  tmp$synonyms <- ifelse(is.na(tmp$synonyms) | tmp$synonyms == "", 
                             tmp$orig_name, 
                             paste(tmp$synonyms, tmp$orig_name, sep = "; "))
  
  # Re-assign the modified subset back to the original rows
  processlist[inc, ] <- tmp
}


# leave a comment for species were original name was kept as current name because of mismatches

missmatch_names_list = c(leave_orig_name1, leave_out_orig_name2)
inc <- with(processlist, (orig_name %in% missmatch_names_list))
if (any(inc, na.rm = TRUE)) {
  
  tmp <- processlist[inc, ]


  # Update notes without overwriting
  tmp$current_name_notes <- "Original species wcvp match was a missmatch"
  
  tmp$wcvp_name = NA
  tmp$wcvp_family= NA
  tmp$wcvp_author = NA
  
  # Re-assign the modified subset back to the original rows
  processlist[inc, ] <- tmp
}

# leave comment for species duplicates
inc <- with(processlist, (orig_name %in% leave_orig_names_dups))
if (any(inc, na.rm = TRUE)) {
  
  tmp <- processlist[inc, ]


  # Update notes without overwriting
  tmp$current_name_notes <- "WCVP name is the same as another species in list"
  
  # Re-assign the modified subset back to the original rows
  processlist[inc, ] <- tmp
}

```

## Case when the Family changed

```{r familychange}

# Identifying species where the name matches but the family is different
familychanged <- processlist %>% 
  filter(orig_name == wcvp_name & 
         current_family != Accepted_family &  
         wcvp_status == "Accepted") %>%
  arrange(match_similarity)

print(paste0("Species with changes in family: ", nrow(familychanged)))

if(nrow(familychanged) > 0){
  datatable(
    familychanged %>% select(orig_family, Accepted_family, orig_name, Accepted_name, wcvp_status, match_similarity), 
    caption = "Species with changes in family",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```


```{r familyfix}
# Define the logical index (inc) using your NEW column names
inc <- with(processlist, (
    !is.na(orig_name) & 
    !is.na(Accepted_name) &  
    orig_name == Accepted_name &   
    wcvp_status == "Accepted" & 
    orig_name %in% familychanged$orig_name &
    !orig_name %in% leave_orig_names
))

# Safety check: are there any matches?
if (any(inc, na.rm = TRUE)) {
  
  # Create the temporary subset
  tmp <- processlist[inc, ]
  
  # Perform updates on the subset
  tmp$origchanged  <- TRUE
  # Update family only if Accepted_family is not NA
  tmp$current_family  <- ifelse(!is.na(tmp$Accepted_family), tmp$Accepted_family, tmp$orig_family)

  new_comment <- "Family changed in WCVP"
  
  # Update notes without overwriting
  tmp$current_name_notes <- ifelse(is.na(tmp$current_name_notes) | tmp$current_name_notes == "", 
                          new_comment, 
                          paste(tmp$current_name_notes, new_comment, sep = " | "))
  
  # Re-assign back to processlist
  processlist[inc, ] <- tmp
}

# --- Sanity check ---
# Check by wcvp_genus 
genus_many_families <- processlist %>%
  mutate(current_genus = word(current_name, 1)) %>%
  group_by(current_genus) %>%
  filter(n_distinct(current_family) > 1) %>% 
  ungroup() %>% 
  select(
    current_family, 
    current_name, 
    orig_family, 
    orig_name, 
    wcvp_family, 
    wcvp_name, 
    current_name_notes,
    current_genus,
  ) %>%
  arrange(current_genus)

if(nrow(genus_many_families) > 0){
  datatable(genus_many_families, caption="Sanity check: Genus with more than one family")
}

# This is because of NA status, i will leave it as it is because they are unidentified species. 

```

## Summary of modifications
```{r summarymod}
# Filter for species that were modified in the main list
species_modified <- processlist %>% 
  filter(!is.na(current_name_notes) & current_name_notes != "") %>% 
  arrange(current_name_notes, orig_name)


# Calculate Percentage of change
change_perc <- (nrow(species_modified) / nrow(processlist)) * 100
print(paste0("Total species modified/consolidated: ", nrow(species_modified)))
print(paste0("Percentage of dataset modified: ", round(change_perc, 2), "%"))

# Save modifications in a separate file (using the path variables from setup)
write_xlsx(species_modified, out_wcvp_changes_list)

# Summary table of change types
knitr::kable(species_modified %>% 
               group_by(current_name_notes) %>% 
               summarise(n_species = n(), .groups = "drop"), 
             caption = "Summary of changes by category")

# Detailed interactive table of all changes
datatable(
  species_modified %>% 
    select(orig_name, wcvp_name, orig_family, wcvp_family, wcvp_status, current_name_notes),
  caption = "Species current name is different from original name after matching with WCVP",
  options = list(scrollX = TRUE, pageLength = 20),
  rownames = FALSE
)
```

## Sanity check:  species were the name didint change and check duplicated species.

```{r}
# 1. Check for species where our final name still differs from the WCVP Accepted Name
species_no_wcvp <- processlist %>% 
  filter(is.na(current_name) | is.na(wcvp_name) | current_name != wcvp_name)

print(paste0("Species where final name differs from WCVP Name: ", nrow(species_no_wcvp)))

if(nrow(species_no_wcvp) > 0){
  datatable(
    species_no_wcvp %>% 
      select(current_name, orig_name, wcvp_name, Name_matched, current_family, wcvp_family, wcvp_status, current_name_notes), 
    caption = "Species requiring manual review (Name mismatch)",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

# 2. Final check for duplicates: This should ideally return 0 rows
final_duplicates <- processlist %>% 
  filter(!is.na(current_name)) %>%
  group_by(current_name) %>% 
  filter(n() > 1) %>% 
  ungroup() %>%
  mutate(mismatch = (orig_name != Name_matched)) %>% 
  arrange(current_name, mismatch, match_similarity) %>%
  select(current_name, wcvp_name, orig_name, Name_matched, wcvp_status, mismatch, match_similarity)

if(nrow(final_duplicates) > 0){
  knitr::kable(final_duplicates, caption = "WARNING: Remaining Duplicates Found")
} else {
  print("Sanity Check Passed: No duplicates remaining in the final list.")
}


# Duplicated names misspelled in the original dataset
# needs removing

processlist <- processlist %>% 
  distinct(current_name, .keep_all = TRUE)


```

### Species with missing information in some column

```{r missinginfo}

# Flags species where the genus column doesn't match the first word of the species name,
# or where essential taxonomic fields are NA.
missing_info <- processlist %>% filter(
   is.na(current_family) | is.na(current_author) | is.na(current_name)
)   

if(nrow(missing_info) > 0) {
  datatable(
    missing_info %>% select(
      current_name, wcvp_name, orig_name,current_family, wcvp_family, orig_family, 
      current_author, wcvp_author, orig_author, 
      current_name_notes
    ),
    caption = "Species with missing or inconsistent taxonomic information",
    options = list(scrollX = TRUE, pageLength = 10),
    rownames = FALSE
  )
}

```

## Save output of all species.
```{r saveoutput}
# Remove some columns
# Standardize lifeform column name and remove technical matching columns
outtaxa <- processlist %>%
  rename(
    wcvp_lifeform_description = lifeform_description
  ) %>%
  select(
     -wcvp_authors, -Name_matched_rank, -Accepted_name, 
    -Accepted_family, -Accepted_name_rank, -Accepted_name_author, 
    -Accepted_name_status, -Accepted_name_genus, -Accepted_name_species, 
    -Accepted_name_infraspecific_rank, -Accepted_name_infraspecies,
    -match_similarity, -match_edit_distance
  )

# Save using the path defined in your setup chunk
write_xlsx(outtaxa, out_wcvp_list)
```

Saved `r nrow(outtaxa)` species with their names verified with WCVP. 